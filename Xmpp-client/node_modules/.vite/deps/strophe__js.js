var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: "\n",
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser2;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/abab/lib/atob.js
var require_atob = __commonJS({
  "node_modules/abab/lib/atob.js"(exports, module) {
    "use strict";
    function atob3(data) {
      if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      data = `${data}`;
      data = data.replace(/[ \t\n\f\r]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/==?$/, "");
      }
      if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {
        return null;
      }
      let output = "";
      let buffer = 0;
      let accumulatedBits = 0;
      for (let i = 0; i < data.length; i++) {
        buffer <<= 6;
        buffer |= atobLookup(data[i]);
        accumulatedBits += 6;
        if (accumulatedBits === 24) {
          output += String.fromCharCode((buffer & 16711680) >> 16);
          output += String.fromCharCode((buffer & 65280) >> 8);
          output += String.fromCharCode(buffer & 255);
          buffer = accumulatedBits = 0;
        }
      }
      if (accumulatedBits === 12) {
        buffer >>= 4;
        output += String.fromCharCode(buffer);
      } else if (accumulatedBits === 18) {
        buffer >>= 2;
        output += String.fromCharCode((buffer & 65280) >> 8);
        output += String.fromCharCode(buffer & 255);
      }
      return output;
    }
    var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function atobLookup(chr) {
      const index = keystr.indexOf(chr);
      return index < 0 ? void 0 : index;
    }
    module.exports = atob3;
  }
});

// node_modules/abab/lib/btoa.js
var require_btoa = __commonJS({
  "node_modules/abab/lib/btoa.js"(exports, module) {
    "use strict";
    function btoa3(s) {
      if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      let i;
      s = `${s}`;
      for (i = 0; i < s.length; i++) {
        if (s.charCodeAt(i) > 255) {
          return null;
        }
      }
      let out = "";
      for (i = 0; i < s.length; i += 3) {
        const groupsOfSix = [void 0, void 0, void 0, void 0];
        groupsOfSix[0] = s.charCodeAt(i) >> 2;
        groupsOfSix[1] = (s.charCodeAt(i) & 3) << 4;
        if (s.length > i + 1) {
          groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;
          groupsOfSix[2] = (s.charCodeAt(i + 1) & 15) << 2;
        }
        if (s.length > i + 2) {
          groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;
          groupsOfSix[3] = s.charCodeAt(i + 2) & 63;
        }
        for (let j = 0; j < groupsOfSix.length; j++) {
          if (typeof groupsOfSix[j] === "undefined") {
            out += "=";
          } else {
            out += btoaLookup(groupsOfSix[j]);
          }
        }
      }
      return out;
    }
    var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function btoaLookup(index) {
      if (index >= 0 && index < 64) {
        return keystr[index];
      }
      return void 0;
    }
    module.exports = btoa3;
  }
});

// node_modules/abab/index.js
var require_abab = __commonJS({
  "node_modules/abab/index.js"(exports, module) {
    "use strict";
    var atob3 = require_atob();
    var btoa3 = require_btoa();
    module.exports = {
      atob: atob3,
      btoa: btoa3
    };
  }
});

// node_modules/strophe.js/src/shims.js
var shims_exports = {};
__export(shims_exports, {
  DOMParser: () => DOMParser,
  WebSocket: () => WebSocket,
  getDummyXMLDOMDocument: () => getDummyXMLDOMDocument
});
function getWebSocketImplementation() {
  if (typeof globalThis.WebSocket === "undefined") {
    try {
      return require_browser();
    } catch (err) {
      throw new Error('You must install the "ws" package to use Strophe in nodejs.');
    }
  }
  return globalThis.WebSocket;
}
var WebSocket = getWebSocketImplementation();
function getDOMParserImplementation() {
  let DOMParserImplementation = globalThis.DOMParser;
  if (typeof DOMParserImplementation === "undefined") {
    try {
      DOMParserImplementation = require_lib().DOMParser;
    } catch (err) {
      throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
    }
  }
  return DOMParserImplementation;
}
var DOMParser = getDOMParserImplementation();
function getDummyXMLDOMDocument() {
  if (typeof document === "undefined") {
    try {
      const DOMImplementation = require_lib().DOMImplementation;
      return new DOMImplementation().createDocument("jabber:client", "strophe", null);
    } catch (err) {
      throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
    }
  }
  return document.implementation.createDocument("jabber:client", "strophe", null);
}

// node_modules/strophe.js/src/utils.js
var utils_exports = {};
__export(utils_exports, {
  addCookies: () => addCookies,
  arrayBufToBase64: () => arrayBufToBase64,
  base64ToArrayBuf: () => base64ToArrayBuf,
  copyElement: () => copyElement,
  createHtml: () => createHtml,
  default: () => utils,
  escapeNode: () => escapeNode,
  forEachChild: () => forEachChild,
  getBareJidFromJid: () => getBareJidFromJid,
  getDomainFromJid: () => getDomainFromJid,
  getNodeFromJid: () => getNodeFromJid,
  getResourceFromJid: () => getResourceFromJid,
  getText: () => getText,
  handleError: () => handleError,
  isTagEqual: () => isTagEqual,
  stringToArrayBuf: () => stringToArrayBuf,
  unescapeNode: () => unescapeNode,
  utf16to8: () => utf16to8,
  validAttribute: () => validAttribute,
  validCSS: () => validCSS,
  validTag: () => validTag,
  xmlElement: () => xmlElement,
  xmlGenerator: () => xmlGenerator,
  xmlHtmlNode: () => xmlHtmlNode,
  xmlTextNode: () => xmlTextNode,
  xmlescape: () => xmlescape,
  xmlunescape: () => xmlunescape,
  xorArrayBuffers: () => xorArrayBuffers
});

// node_modules/strophe.js/src/constants.js
var NS = {
  HTTPBIND: "http://jabber.org/protocol/httpbind",
  BOSH: "urn:xmpp:xbosh",
  CLIENT: "jabber:client",
  AUTH: "jabber:iq:auth",
  ROSTER: "jabber:iq:roster",
  PROFILE: "jabber:iq:profile",
  DISCO_INFO: "http://jabber.org/protocol/disco#info",
  DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
  MUC: "http://jabber.org/protocol/muc",
  SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
  STREAM: "http://etherx.jabber.org/streams",
  FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
  BIND: "urn:ietf:params:xml:ns:xmpp-bind",
  SESSION: "urn:ietf:params:xml:ns:xmpp-session",
  VERSION: "jabber:iq:version",
  STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
  XHTML_IM: "http://jabber.org/protocol/xhtml-im",
  XHTML: "http://www.w3.org/1999/xhtml"
};
var XHTML = {
  tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
  attributes: {
    "a": ["href"],
    "blockquote": ["style"],
    /** @type {never[]} */
    "br": [],
    "cite": ["style"],
    /** @type {never[]} */
    "em": [],
    "img": ["src", "alt", "style", "height", "width"],
    "li": ["style"],
    "ol": ["style"],
    "p": ["style"],
    "span": ["style"],
    /** @type {never[]} */
    "strong": [],
    "ul": ["style"],
    /** @type {never[]} */
    "body": []
  },
  css: [
    "background-color",
    "color",
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "margin-left",
    "margin-right",
    "text-align",
    "text-decoration"
  ]
};
var Status = {
  ERROR: 0,
  CONNECTING: 1,
  CONNFAIL: 2,
  AUTHENTICATING: 3,
  AUTHFAIL: 4,
  CONNECTED: 5,
  DISCONNECTED: 6,
  DISCONNECTING: 7,
  ATTACHED: 8,
  REDIRECT: 9,
  CONNTIMEOUT: 10,
  BINDREQUIRED: 11,
  ATTACHFAIL: 12,
  RECONNECTING: 13
};
var ErrorCondition = {
  BAD_FORMAT: "bad-format",
  CONFLICT: "conflict",
  MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
  NO_AUTH_MECH: "no-auth-mech",
  UNKNOWN_REASON: "unknown"
};
var LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4
};
var ElementType = {
  NORMAL: 1,
  TEXT: 3,
  CDATA: 4,
  FRAGMENT: 11
};

// node_modules/strophe.js/src/log.js
var logLevel = LOG_LEVELS.DEBUG;
var log = {
  /**
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    if (level < LOG_LEVELS.DEBUG || level > LOG_LEVELS.FATAL) {
      throw new Error("Invalid log level supplied to setLogLevel");
    }
    logLevel = level;
  },
  /**
   *
   * Please note that data sent and received over the wire is logged
   * via {@link Strophe.Connection#rawInput|Strophe.Connection.rawInput()}
   * and {@link Strophe.Connection#rawOutput|Strophe.Connection.rawOutput()}.
   *
   * The different levels and their meanings are
   *
   *   DEBUG - Messages useful for debugging purposes.
   *   INFO - Informational messages.  This is mostly information like
   *     'disconnect was called' or 'SASL auth succeeded'.
   *   WARN - Warnings about potential problems.  This is mostly used
   *     to report transient connection errors like request timeouts.
   *   ERROR - Some error occurred.
   *   FATAL - A non-recoverable fatal error occurred.
   *
   * @param {number} level - The log level of the log message.
   *     This will be one of the values in Strophe.LOG_LEVELS.
   * @param {string} msg - The log message.
   */
  log(level, msg) {
    if (level < logLevel) {
      return;
    }
    if (level >= LOG_LEVELS.ERROR) {
      console == null ? void 0 : console.error(msg);
    } else if (level === LOG_LEVELS.INFO) {
      console == null ? void 0 : console.info(msg);
    } else if (level === LOG_LEVELS.WARN) {
      console == null ? void 0 : console.warn(msg);
    } else if (level === LOG_LEVELS.DEBUG) {
      console == null ? void 0 : console.debug(msg);
    }
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.DEBUG level.
   * @param {string} msg - The log message.
   */
  debug(msg) {
    this.log(LOG_LEVELS.DEBUG, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.INFO level.
   * @param {string} msg - The log message.
   */
  info(msg) {
    this.log(LOG_LEVELS.INFO, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.WARN level.
   * @param {string} msg - The log message.
   */
  warn(msg) {
    this.log(LOG_LEVELS.WARN, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.ERROR level.
   * @param {string} msg - The log message.
   */
  error(msg) {
    this.log(LOG_LEVELS.ERROR, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.FATAL level.
   * @param {string} msg - The log message.
   */
  fatal(msg) {
    this.log(LOG_LEVELS.FATAL, msg);
  }
};
var log_default = log;

// node_modules/strophe.js/src/utils.js
function handleError(e) {
  if (typeof e.stack !== "undefined") {
    log_default.fatal(e.stack);
  }
  log_default.fatal("error: " + e.message);
}
function utf16to8(str) {
  let out = "";
  const len = str.length;
  for (let i = 0; i < len; i++) {
    const c = str.charCodeAt(i);
    if (c >= 0 && c <= 127) {
      out += str.charAt(i);
    } else if (c > 2047) {
      out += String.fromCharCode(224 | c >> 12 & 15);
      out += String.fromCharCode(128 | c >> 6 & 63);
      out += String.fromCharCode(128 | c >> 0 & 63);
    } else {
      out += String.fromCharCode(192 | c >> 6 & 31);
      out += String.fromCharCode(128 | c >> 0 & 63);
    }
  }
  return out;
}
function xorArrayBuffers(x, y) {
  const xIntArray = new Uint8Array(x);
  const yIntArray = new Uint8Array(y);
  const zIntArray = new Uint8Array(x.byteLength);
  for (let i = 0; i < x.byteLength; i++) {
    zIntArray[i] = xIntArray[i] ^ yIntArray[i];
  }
  return zIntArray.buffer;
}
function arrayBufToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToArrayBuf(str) {
  var _a;
  return (_a = Uint8Array.from(atob(str), (c) => c.charCodeAt(0))) == null ? void 0 : _a.buffer;
}
function stringToArrayBuf(str) {
  const bytes = new TextEncoder().encode(str);
  return bytes.buffer;
}
function addCookies(cookies) {
  if (typeof document === "undefined") {
    log_default.error(`addCookies: not adding any cookies, since there's no document object`);
  }
  cookies = cookies || {};
  for (const cookieName in cookies) {
    if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {
      let expires = "";
      let domain = "";
      let path = "";
      const cookieObj = cookies[cookieName];
      const isObj = typeof cookieObj === "object";
      const cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
      if (isObj) {
        expires = cookieObj.expires ? ";expires=" + cookieObj.expires : "";
        domain = cookieObj.domain ? ";domain=" + cookieObj.domain : "";
        path = cookieObj.path ? ";path=" + cookieObj.path : "";
      }
      document.cookie = cookieName + "=" + cookieValue + expires + domain + path;
    }
  }
}
var _xmlGenerator = null;
function xmlGenerator() {
  if (!_xmlGenerator) {
    _xmlGenerator = getDummyXMLDOMDocument();
  }
  return _xmlGenerator;
}
function xmlTextNode(text) {
  return xmlGenerator().createTextNode(text);
}
function xmlHtmlNode(html) {
  const parser = new DOMParser();
  return parser.parseFromString(html, "text/xml");
}
function xmlElement(name, attrs, text) {
  if (!name) return null;
  const node = xmlGenerator().createElement(name);
  if (text && (typeof text === "string" || typeof text === "number")) {
    node.appendChild(xmlTextNode(text.toString()));
  } else if (typeof attrs === "string" || typeof attrs === "number") {
    node.appendChild(xmlTextNode(
      /** @type {number|string} */
      attrs.toString()
    ));
    return node;
  }
  if (!attrs) {
    return node;
  } else if (Array.isArray(attrs)) {
    for (const attr of attrs) {
      if (Array.isArray(attr)) {
        if (attr[0] != null && attr[1] != null) {
          node.setAttribute(attr[0], attr[1]);
        }
      }
    }
  } else if (typeof attrs === "object") {
    for (const k of Object.keys(attrs)) {
      if (k && attrs[k] != null) {
        node.setAttribute(k, attrs[k].toString());
      }
    }
  }
  return node;
}
function validTag(tag) {
  for (let i = 0; i < XHTML.tags.length; i++) {
    if (tag === XHTML.tags[i]) {
      return true;
    }
  }
  return false;
}
function validAttribute(tag, attribute) {
  const attrs = XHTML.attributes[
    /** @type {XHTMLAttrs} */
    tag
  ];
  if ((attrs == null ? void 0 : attrs.length) > 0) {
    for (let i = 0; i < attrs.length; i++) {
      if (attribute === attrs[i]) {
        return true;
      }
    }
  }
  return false;
}
function validCSS(style) {
  for (let i = 0; i < XHTML.css.length; i++) {
    if (style === XHTML.css[i]) {
      return true;
    }
  }
  return false;
}
function createFromHtmlElement(elem) {
  let el;
  const tag = elem.nodeName.toLowerCase();
  if (validTag(tag)) {
    try {
      el = xmlElement(tag);
      if (tag in XHTML.attributes) {
        const attrs = XHTML.attributes[
          /** @type {XHTMLAttrs} */
          tag
        ];
        for (let i = 0; i < attrs.length; i++) {
          const attribute = attrs[i];
          let value = elem.getAttribute(attribute);
          if (typeof value === "undefined" || value === null || value === "") {
            continue;
          }
          if (attribute === "style" && typeof value === "object") {
            value = /** @type {Object.<'csstext',string>} */
            value.cssText ?? value;
          }
          if (attribute === "style") {
            const css = [];
            const cssAttrs = value.split(";");
            for (let j = 0; j < cssAttrs.length; j++) {
              const attr = cssAttrs[j].split(":");
              const cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
              if (validCSS(cssName)) {
                const cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                css.push(cssName + ": " + cssValue);
              }
            }
            if (css.length > 0) {
              value = css.join("; ");
              el.setAttribute(attribute, value);
            }
          } else {
            el.setAttribute(attribute, value);
          }
        }
        for (let i = 0; i < elem.childNodes.length; i++) {
          el.appendChild(createHtml(elem.childNodes[i]));
        }
      }
    } catch (e) {
      el = xmlTextNode("");
    }
  } else {
    el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < elem.childNodes.length; i++) {
      el.appendChild(createHtml(elem.childNodes[i]));
    }
  }
  return el;
}
function createHtml(node) {
  if (node.nodeType === ElementType.NORMAL) {
    return createFromHtmlElement(
      /** @type {HTMLElement} */
      node
    );
  } else if (node.nodeType === ElementType.FRAGMENT) {
    const el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < node.childNodes.length; i++) {
      el.appendChild(createHtml(node.childNodes[i]));
    }
    return el;
  } else if (node.nodeType === ElementType.TEXT) {
    return xmlTextNode(node.nodeValue);
  }
}
function copyElement(node) {
  let out;
  if (node.nodeType === ElementType.NORMAL) {
    const el = (
      /** @type {Element} */
      node
    );
    out = xmlElement(el.tagName);
    for (let i = 0; i < el.attributes.length; i++) {
      out.setAttribute(el.attributes[i].nodeName, el.attributes[i].value);
    }
    for (let i = 0; i < el.childNodes.length; i++) {
      out.appendChild(copyElement(el.childNodes[i]));
    }
  } else if (node.nodeType === ElementType.TEXT) {
    out = xmlGenerator().createTextNode(node.nodeValue);
  }
  return out;
}
function xmlescape(text) {
  text = text.replace(/\&/g, "&amp;");
  text = text.replace(/</g, "&lt;");
  text = text.replace(/>/g, "&gt;");
  text = text.replace(/'/g, "&apos;");
  text = text.replace(/"/g, "&quot;");
  return text;
}
function xmlunescape(text) {
  text = text.replace(/\&amp;/g, "&");
  text = text.replace(/&lt;/g, "<");
  text = text.replace(/&gt;/g, ">");
  text = text.replace(/&apos;/g, "'");
  text = text.replace(/&quot;/g, '"');
  return text;
}
function forEachChild(elem, elemName, func) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
      func(childNode);
    }
  }
}
function isTagEqual(el, name) {
  return el.tagName === name;
}
function getText(elem) {
  var _a, _b;
  if (!elem) {
    return null;
  }
  let str = "";
  if (!((_a = elem.childNodes) == null ? void 0 : _a.length) && elem.nodeType === ElementType.TEXT) {
    str += elem.nodeValue;
  }
  for (let i = 0; i < ((_b = elem.childNodes) == null ? void 0 : _b.length); i++) {
    if (elem.childNodes[i].nodeType === ElementType.TEXT) {
      str += elem.childNodes[i].nodeValue;
    }
  }
  return xmlescape(str);
}
function escapeNode(node) {
  if (typeof node !== "string") {
    return node;
  }
  return node.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40");
}
function unescapeNode(node) {
  if (typeof node !== "string") {
    return node;
  }
  return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\");
}
function getNodeFromJid(jid) {
  if (jid.indexOf("@") < 0) {
    return null;
  }
  return jid.split("@")[0];
}
function getDomainFromJid(jid) {
  const bare = getBareJidFromJid(jid);
  if (bare.indexOf("@") < 0) {
    return bare;
  } else {
    const parts = bare.split("@");
    parts.splice(0, 1);
    return parts.join("@");
  }
}
function getResourceFromJid(jid) {
  if (!jid) {
    return null;
  }
  const s = jid.split("/");
  if (s.length < 2) {
    return null;
  }
  s.splice(0, 1);
  return s.join("/");
}
function getBareJidFromJid(jid) {
  return jid ? jid.split("/")[0] : null;
}
var utils = {
  utf16to8,
  xorArrayBuffers,
  arrayBufToBase64,
  base64ToArrayBuf,
  stringToArrayBuf,
  addCookies
};

// node_modules/strophe.js/src/builder.js
function $build(name, attrs) {
  return new Builder(name, attrs);
}
function $msg(attrs) {
  return new Builder("message", attrs);
}
function $iq(attrs) {
  return new Builder("iq", attrs);
}
function $pres(attrs) {
  return new Builder("presence", attrs);
}
var Builder = class _Builder {
  /**
   * @typedef {Object.<string, string|number>} StanzaAttrs
   * @property {string} [StanzaAttrs.xmlns]
   */
  /**
   * The attributes should be passed in object notation.
   * @param {string} name - The name of the root element.
   * @param {StanzaAttrs} [attrs] - The attributes for the root element in object notation.
   * @example const b = new Builder('message', {to: 'you', from: 'me'});
   * @example const b = new Builder('messsage', {'xml:lang': 'en'});
   */
  constructor(name, attrs) {
    if (name === "presence" || name === "message" || name === "iq") {
      if (attrs && !attrs.xmlns) {
        attrs.xmlns = NS.CLIENT;
      } else if (!attrs) {
        attrs = { xmlns: NS.CLIENT };
      }
    }
    this.nodeTree = xmlElement(name, attrs);
    this.node = this.nodeTree;
  }
  /**
   * Render a DOM element and all descendants to a String.
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  static serialize(elem) {
    if (!elem) return null;
    const el = elem instanceof _Builder ? elem.tree() : elem;
    const names = [...Array(el.attributes.length).keys()].map((i) => el.attributes[i].nodeName);
    names.sort();
    let result = names.reduce(
      (a, n) => `${a} ${n}="${xmlescape(el.attributes.getNamedItem(n).value)}"`,
      `<${el.nodeName}`
    );
    if (el.childNodes.length > 0) {
      result += ">";
      for (let i = 0; i < el.childNodes.length; i++) {
        const child = el.childNodes[i];
        switch (child.nodeType) {
          case ElementType.NORMAL:
            result += _Builder.serialize(
              /** @type {Element} */
              child
            );
            break;
          case ElementType.TEXT:
            result += xmlescape(child.nodeValue);
            break;
          case ElementType.CDATA:
            result += "<![CDATA[" + child.nodeValue + "]]>";
        }
      }
      result += "</" + el.nodeName + ">";
    } else {
      result += "/>";
    }
    return result;
  }
  /**
   * Return the DOM tree.
   *
   * This function returns the current DOM tree as an element object.  This
   * is suitable for passing to functions like Strophe.Connection.send().
   *
   * @return {Element} The DOM tree as a element object.
   */
  tree() {
    return this.nodeTree;
  }
  /**
   * Serialize the DOM tree to a String.
   *
   * This function returns a string serialization of the current DOM
   * tree.  It is often used internally to pass data to a
   * Strophe.Request object.
   *
   * @return {string} The serialized DOM tree in a String.
   */
  toString() {
    return _Builder.serialize(this.nodeTree);
  }
  /**
   * Make the current parent element the new current element.
   * This function is often used after c() to traverse back up the tree.
   *
   * @example
   *  // For example, to add two children to the same element
   *  builder.c('child1', {}).up().c('child2', {});
   *
   * @return {Builder} The Strophe.Builder object.
   */
  up() {
    this.node = this.node.parentElement ? this.node.parentElement : (
      /** @type {Element} */
      this.node.parentNode
    );
    return this;
  }
  /**
   * Make the root element the new current element.
   *
   * When at a deeply nested element in the tree, this function can be used
   * to jump back to the root of the tree, instead of having to repeatedly
   * call up().
   *
   * @return {Builder} The Strophe.Builder object.
   */
  root() {
    this.node = this.nodeTree;
    return this;
  }
  /**
   * Add or modify attributes of the current element.
   *
   * The attributes should be passed in object notation.
   * This function does not move the current element pointer.
   * @param {Object.<string, string|number|null>} moreattrs - The attributes to add/modify in object notation.
   *  If an attribute is set to `null` or `undefined`, it will be removed.
   * @return {Builder} The Strophe.Builder object.
   */
  attrs(moreattrs) {
    for (const k in moreattrs) {
      if (Object.prototype.hasOwnProperty.call(moreattrs, k)) {
        if (moreattrs[k] != null) {
          this.node.setAttribute(k, moreattrs[k].toString());
        } else {
          this.node.removeAttribute(k);
        }
      }
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function moves the current element pointer to the child,
   * unless text is provided.  If you need to add another child, it
   * is necessary to use up() to go back to the parent in the tree.
   *
   * @param {string} name - The name of the child.
   * @param {Object.<string, string>|string} [attrs] - The attributes of the child in object notation.
   * @param {string} [text] - The text to add to the child.
   *
   * @return {Builder} The Strophe.Builder object.
   */
  c(name, attrs, text) {
    const child = xmlElement(name, attrs, text);
    this.node.appendChild(child);
    if (typeof text !== "string" && typeof text !== "number") {
      this.node = child;
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function is the same as c() except that instead of using a
   * name and an attributes object to create the child it uses an
   * existing DOM element object.
   *
   * @param {Element} elem - A DOM element.
   * @return {Builder} The Strophe.Builder object.
   */
  cnode(elem) {
    let impNode;
    const xmlGen = xmlGenerator();
    try {
      impNode = xmlGen.importNode !== void 0;
    } catch (e) {
      impNode = false;
    }
    const newElem = impNode ? xmlGen.importNode(elem, true) : copyElement(elem);
    this.node.appendChild(newElem);
    this.node = /** @type {Element} */
    newElem;
    return this;
  }
  /**
   * Add a child text element.
   *
   * This *does not* make the child the new current element since there
   * are no children of text elements.
   *
   * @param {string} text - The text data to append to the current element.
   * @return {Builder} The Strophe.Builder object.
   */
  t(text) {
    const child = xmlTextNode(text);
    this.node.appendChild(child);
    return this;
  }
  /**
   * Replace current element contents with the HTML passed in.
   *
   * This *does not* make the child the new current element
   *
   * @param {string} html - The html to insert as contents of current element.
   * @return {Builder} The Strophe.Builder object.
   */
  h(html) {
    const fragment = xmlGenerator().createElement("body");
    fragment.innerHTML = html;
    const xhtml = createHtml(fragment);
    while (xhtml.childNodes.length > 0) {
      this.node.appendChild(xhtml.childNodes[0]);
    }
    return this;
  }
};
var builder_default = Builder;

// node_modules/strophe.js/src/request.js
var _requestId = 0;
var Request = class {
  /**
   * Create and initialize a new Request object.
   *
   * @param {Element} elem - The XML data to be sent in the request.
   * @param {Function} func - The function that will be called when the
   *     XMLHttpRequest readyState changes.
   * @param {number} rid - The BOSH rid attribute associated with this request.
   * @param {number} [sends=0] - The number of times this same request has been sent.
   */
  constructor(elem, func, rid, sends = 0) {
    this.id = ++_requestId;
    this.xmlData = elem;
    this.data = builder_default.serialize(elem);
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends;
    this.abort = false;
    this.dead = null;
    this.age = () => this.date ? ((/* @__PURE__ */ new Date()).valueOf() - this.date.valueOf()) / 1e3 : 0;
    this.timeDead = () => this.dead ? ((/* @__PURE__ */ new Date()).valueOf() - this.dead.valueOf()) / 1e3 : 0;
    this.xhr = this._newXHR();
  }
  /**
   * Get a response from the underlying XMLHttpRequest.
   * This function attempts to get a response from the request and checks
   * for errors.
   * @throws "parsererror" - A parser error occured.
   * @throws "bad-format" - The entity has sent XML that cannot be processed.
   * @return {Element} - The DOM element tree of the response.
   */
  getResponse() {
    var _a;
    let node = (_a = this.xhr.responseXML) == null ? void 0 : _a.documentElement;
    if (node) {
      if (node.tagName === "parsererror") {
        log_default.error("invalid response received");
        log_default.error("responseText: " + this.xhr.responseText);
        log_default.error("responseXML: " + builder_default.serialize(node));
        throw new Error("parsererror");
      }
    } else if (this.xhr.responseText) {
      log_default.debug("Got responseText but no responseXML; attempting to parse it with DOMParser...");
      node = new DOMParser().parseFromString(this.xhr.responseText, "application/xml").documentElement;
      const parserError = node == null ? void 0 : node.getElementsByTagName("parsererror").item(0);
      if (!node || parserError) {
        if (parserError) {
          log_default.error("invalid response received: " + parserError.textContent);
          log_default.error("responseText: " + this.xhr.responseText);
        }
        const error = new Error();
        error.name = ErrorCondition.BAD_FORMAT;
        throw error;
      }
    }
    return node;
  }
  /**
   * _Private_ helper function to create XMLHttpRequests.
   * This function creates XMLHttpRequests across all implementations.
   * @private
   * @return {XMLHttpRequest}
   */
  _newXHR() {
    const xhr = new XMLHttpRequest();
    if (xhr.overrideMimeType) {
      xhr.overrideMimeType("text/xml; charset=utf-8");
    }
    xhr.onreadystatechange = this.func.bind(null, this);
    return xhr;
  }
};
var request_default = Request;

// node_modules/strophe.js/src/bosh.js
var timeoutMultiplier = 1.1;
var secondaryTimeoutMultiplier = 0.1;
var Bosh = class _Bosh {
  /**
   * @param {Connection} connection - The Connection that will use BOSH.
   */
  constructor(connection) {
    this._conn = connection;
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.hold = 1;
    this.wait = 60;
    this.window = 5;
    this.errors = 0;
    this.inactivity = null;
    this.strip = _Bosh.prototype.strip ?? false;
    this.lastResponseHeaders = null;
    this._requests = [];
  }
  /**
   * @param {number} m
   */
  static setTimeoutMultiplier(m) {
    timeoutMultiplier = m;
  }
  /**
   * @returns {number}
   */
  static getTimeoutMultplier() {
    return timeoutMultiplier;
  }
  /**
   * @param {number} m
   */
  static setSecondaryTimeoutMultiplier(m) {
    secondaryTimeoutMultiplier = m;
  }
  /**
   * @returns {number}
   */
  static getSecondaryTimeoutMultplier() {
    return secondaryTimeoutMultiplier;
  }
  /**
   * _Private_ helper function to generate the <body/> wrapper for BOSH.
   * @private
   * @return {Builder} - A Builder with a <body/> element.
   */
  _buildBody() {
    const bodyWrap = $build("body", {
      "rid": this.rid++,
      "xmlns": NS.HTTPBIND
    });
    if (this.sid !== null) {
      bodyWrap.attrs({ "sid": this.sid });
    }
    if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
      this._cacheSession();
    }
    return bodyWrap;
  }
  /**
   * Reset the connection.
   * This function is called by the reset function of the Connection
   */
  _reset() {
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.errors = 0;
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function that initializes the BOSH connection.
   * Creates and sends the Request that initializes the BOSH connection.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} route
   */
  _connect(wait, hold, route) {
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.errors = 0;
    const body = this._buildBody().attrs({
      "to": this._conn.domain,
      "xml:lang": "en",
      "wait": this.wait,
      "hold": this.hold,
      "content": "text/xml; charset=utf-8",
      "ver": "1.6",
      "xmpp:version": "1.0",
      "xmlns:xmpp": NS.BOSH
    });
    if (route) {
      body.attrs({ route });
    }
    const _connect_cb = this._conn._connect_cb;
    this._requests.push(
      new request_default(
        body.tree(),
        this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string} jid - The full JID that is bound by the session.
   * @param {string} sid - The SID of the BOSH session.
   * @param {number} rid - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _attach(jid, sid, rid, callback, wait, hold, wind) {
    this._conn.jid = jid;
    this.sid = sid;
    this.rid = rid;
    this._conn.connect_callback = callback;
    this._conn.domain = getDomainFromJid(this._conn.jid);
    this._conn.authenticated = true;
    this._conn.connected = true;
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.window = wind || this.window;
    this._conn._changeConnectStatus(Status.ATTACHED, null);
  }
  /**
   * Attempt to restore a cached BOSH session
   *
   * @param {string} jid - The full JID that is bound by the session.
   *     This parameter is optional but recommended, specifically in cases
   *     where prebinded BOSH sessions are used where it's important to know
   *     that the right session is being restored.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _restore(jid, callback, wait, hold, wind) {
    const session = JSON.parse(sessionStorage.getItem("strophe-bosh-session"));
    if (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || getBareJidFromJid(session.jid) === getBareJidFromJid(jid) || // If authcid is null, then it's an anonymous login, so
    // we compare only the domains:
    getNodeFromJid(jid) === null && getDomainFromJid(session.jid) === jid)) {
      this._conn.restored = true;
      this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
    } else {
      const error = new Error("_restore: no restoreable session.");
      error.name = "StropheSessionError";
      throw error;
    }
  }
  /**
   * _Private_ handler for the beforeunload event.
   * This handler is used to process the Bosh-part of the initial request.
   * @private
   */
  _cacheSession() {
    if (this._conn.authenticated) {
      if (this._conn.jid && this.rid && this.sid) {
        sessionStorage.setItem(
          "strophe-bosh-session",
          JSON.stringify({
            "jid": this._conn.jid,
            "rid": this.rid,
            "sid": this.sid
          })
        );
      }
    } else {
      sessionStorage.removeItem("strophe-bosh-session");
    }
  }
  /**
   * _Private_ handler for initial connection request.
   * This handler is used to process the Bosh-part of the initial request.
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const typ = bodyWrap.getAttribute("type");
    if (typ !== null && typ === "terminate") {
      let cond = bodyWrap.getAttribute("condition");
      log_default.error("BOSH-Connection failed: " + cond);
      const conflict = bodyWrap.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._conn._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "unknown");
      }
      this._conn._doDisconnect(cond);
      return Status.CONNFAIL;
    }
    if (!this.sid) {
      this.sid = bodyWrap.getAttribute("sid");
    }
    const wind = bodyWrap.getAttribute("requests");
    if (wind) {
      this.window = parseInt(wind, 10);
    }
    const hold = bodyWrap.getAttribute("hold");
    if (hold) {
      this.hold = parseInt(hold, 10);
    }
    const wait = bodyWrap.getAttribute("wait");
    if (wait) {
      this.wait = parseInt(wait, 10);
    }
    const inactivity = bodyWrap.getAttribute("inactivity");
    if (inactivity) {
      this.inactivity = parseInt(inactivity, 10);
    }
  }
  /**
   * _Private_ part of Connection.disconnect for Bosh
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    this._sendTerminate(pres);
  }
  /**
   * _Private_ function to disconnect.
   * Resets the SID and RID.
   */
  _doDisconnect() {
    this.sid = null;
    this.rid = Math.floor(Math.random() * 4294967295);
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function to check if the Request queue is empty.
   * @return {boolean} - True, if there are no Requests queued, False otherwise.
   */
  _emptyQueue() {
    return this._requests.length === 0;
  }
  /**
   * _Private_ function to call error handlers registered for HTTP errors.
   * @private
   * @param {Request} req - The request that is changing readyState.
   */
  _callProtocolErrorHandlers(req) {
    const reqStatus = _Bosh._getRequestStatus(req);
    const err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
    if (err_callback) {
      err_callback.call(this, reqStatus);
    }
  }
  /**
   * _Private_ function to handle the error count.
   *
   * Requests are resent automatically until their error count reaches
   * 5.  Each time an error is encountered, this function is called to
   * increment the count and disconnect if the count is too high.
   * @private
   * @param {number} reqStatus - The request status.
   */
  _hitError(reqStatus) {
    this.errors++;
    log_default.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
    if (this.errors > 4) {
      this._conn._onDisconnectTimeout();
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received and sends a blank poll request.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log_default.warn(
      "Server did not yet offer a supported authentication mechanism. Sending a blank poll request."
    );
    if (callback) {
      callback = callback.bind(this._conn);
    } else {
      callback = this._conn._connect_cb.bind(this._conn);
    }
    const body = this._buildBody();
    this._requests.push(
      new request_default(
        body.tree(),
        this._onRequestStateChange.bind(this, callback),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   * Cancels all remaining Requests and clears the queue.
   */
  _onDisconnectTimeout() {
    this._abortAllRequests();
  }
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
    while (this._requests.length > 0) {
      const req = this._requests.pop();
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
    }
  }
  /**
   * _Private_ handler called by {@link Connection#_onIdle|Connection._onIdle()}.
   * Sends all queued Requests or polls with empty Request if there are none.
   */
  _onIdle() {
    const data = this._conn._data;
    if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
      log_default.debug("no requests during idle cycle, sending blank request");
      data.push(null);
    }
    if (this._conn.paused) {
      return;
    }
    if (this._requests.length < 2 && data.length > 0) {
      const body = this._buildBody();
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          if (data[i] === "restart") {
            body.attrs({
              "to": this._conn.domain,
              "xml:lang": "en",
              "xmpp:restart": "true",
              "xmlns:xmpp": NS.BOSH
            });
          } else {
            body.cnode(
              /** @type {Element} */
              data[i]
            ).up();
          }
        }
      }
      delete this._conn._data;
      this._conn._data = [];
      this._requests.push(
        new request_default(
          body.tree(),
          this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
          Number(body.tree().getAttribute("rid"))
        )
      );
      this._throttledRequestHandler();
    }
    if (this._requests.length > 0) {
      const time_elapsed = this._requests[0].age();
      if (this._requests[0].dead !== null) {
        if (this._requests[0].timeDead() > Math.floor(timeoutMultiplier * this.wait)) {
          this._throttledRequestHandler();
        }
      }
      if (time_elapsed > Math.floor(timeoutMultiplier * this.wait)) {
        log_default.warn(
          "Request " + this._requests[0].id + " timed out, over " + Math.floor(timeoutMultiplier * this.wait) + " seconds since last activity"
        );
        this._throttledRequestHandler();
      }
    }
  }
  /**
   * Returns the HTTP status code from a {@link Request}
   * @private
   * @param {Request} req - The {@link Request} instance.
   * @param {number} [def] - The default value that should be returned if no status value was found.
   */
  static _getRequestStatus(req, def) {
    let reqStatus;
    if (req.xhr.readyState === 4) {
      try {
        reqStatus = req.xhr.status;
      } catch (e) {
        log_default.error("Caught an error while retrieving a request's status, reqStatus: " + reqStatus);
      }
    }
    if (typeof reqStatus === "undefined") {
      reqStatus = typeof def === "number" ? def : 0;
    }
    return reqStatus;
  }
  /**
   * _Private_ handler for {@link Request} state changes.
   *
   * This function is called when the XMLHttpRequest readyState changes.
   * It contains a lot of error handling logic for the many ways that
   * requests can fail, and calls the request callback when requests
   * succeed.
   * @private
   *
   * @param {Function} func - The handler for the request.
   * @param {Request} req - The request that is changing readyState.
   */
  _onRequestStateChange(func, req) {
    log_default.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
    if (req.abort) {
      req.abort = false;
      return;
    }
    if (req.xhr.readyState !== 4) {
      return;
    }
    const reqStatus = _Bosh._getRequestStatus(req);
    this.lastResponseHeaders = req.xhr.getAllResponseHeaders();
    if (this._conn.disconnecting && reqStatus >= 400) {
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      return;
    }
    const reqIs0 = this._requests[0] === req;
    const reqIs1 = this._requests[1] === req;
    const valid_request = reqStatus > 0 && reqStatus < 500;
    const too_many_retries = req.sends > this._conn.maxRetries;
    if (valid_request || too_many_retries) {
      this._removeRequest(req);
      log_default.debug("request id " + req.id + " should now be removed");
    }
    if (reqStatus === 200) {
      if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(timeoutMultiplier * this.wait)) {
        this._restartRequest(0);
      }
      this._conn.nextValidRid(req.rid + 1);
      log_default.debug("request id " + req.id + "." + req.sends + " got 200");
      func(req);
      this.errors = 0;
    } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12e3) {
      log_default.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      if (reqStatus >= 400 && reqStatus < 500) {
        this._conn._changeConnectStatus(Status.DISCONNECTING, null);
        this._conn._doDisconnect();
      }
    } else {
      log_default.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
    }
    if (!valid_request && !too_many_retries) {
      this._throttledRequestHandler();
    } else if (too_many_retries && !this._conn.connected) {
      this._conn._changeConnectStatus(Status.CONNFAIL, "giving-up");
    }
  }
  /**
   * _Private_ function to process a request in the queue.
   *
   * This function takes requests off the queue and sends them and
   * restarts dead requests.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _processRequest(i) {
    var _a, _b, _c, _d, _e, _f;
    let req = this._requests[i];
    const reqStatus = _Bosh._getRequestStatus(req, -1);
    if (req.sends > this._conn.maxRetries) {
      this._conn._onDisconnectTimeout();
      return;
    }
    const time_elapsed = req.age();
    const primary_timeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(timeoutMultiplier * this.wait);
    const secondary_timeout = req.dead !== null && req.timeDead() > Math.floor(secondaryTimeoutMultiplier * this.wait);
    const server_error = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);
    if (primary_timeout || secondary_timeout || server_error) {
      if (secondary_timeout) {
        log_default.error(`Request ${this._requests[i].id} timed out (secondary), restarting`);
      }
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
      this._requests[i] = new request_default(req.xmlData, req.origFunc, req.rid, req.sends);
      req = this._requests[i];
    }
    if (req.xhr.readyState === 0) {
      log_default.debug("request id " + req.id + "." + req.sends + " posting");
      try {
        const content_type = this._conn.options.contentType || "text/xml; charset=utf-8";
        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
        if (typeof req.xhr.setRequestHeader !== "undefined") {
          req.xhr.setRequestHeader("Content-Type", content_type);
        }
        if (this._conn.options.withCredentials) {
          req.xhr.withCredentials = true;
        }
      } catch (e2) {
        log_default.error("XHR open failed: " + e2.toString());
        if (!this._conn.connected) {
          this._conn._changeConnectStatus(Status.CONNFAIL, "bad-service");
        }
        this._conn.disconnect();
        return;
      }
      const sendFunc = () => {
        req.date = (/* @__PURE__ */ new Date()).valueOf();
        if (this._conn.options.customHeaders) {
          const headers = this._conn.options.customHeaders;
          for (const header in headers) {
            if (Object.prototype.hasOwnProperty.call(headers, header)) {
              req.xhr.setRequestHeader(header, headers[header]);
            }
          }
        }
        req.xhr.send(req.data);
      };
      if (req.sends > 1) {
        const backoff = Math.min(Math.floor(timeoutMultiplier * this.wait), Math.pow(req.sends, 3)) * 1e3;
        setTimeout(function() {
          sendFunc();
        }, backoff);
      } else {
        sendFunc();
      }
      req.sends++;
      if (this.strip && req.xmlData.nodeName === "body" && req.xmlData.childNodes.length) {
        (_b = (_a = this._conn).xmlOutput) == null ? void 0 : _b.call(_a, req.xmlData.children[0]);
      } else {
        (_d = (_c = this._conn).xmlOutput) == null ? void 0 : _d.call(_c, req.xmlData);
      }
      (_f = (_e = this._conn).rawOutput) == null ? void 0 : _f.call(_e, req.data);
    } else {
      log_default.debug(
        "_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState
      );
    }
  }
  /**
   * _Private_ function to remove a request from the queue.
   * @private
   * @param {Request} req - The request to remove.
   */
  _removeRequest(req) {
    log_default.debug("removing request");
    for (let i = this._requests.length - 1; i >= 0; i--) {
      if (req === this._requests[i]) {
        this._requests.splice(i, 1);
      }
    }
    req.xhr.onreadystatechange = function() {
    };
    this._throttledRequestHandler();
  }
  /**
   * _Private_ function to restart a request that is presumed dead.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _restartRequest(i) {
    const req = this._requests[i];
    if (req.dead === null) {
      req.dead = /* @__PURE__ */ new Date();
    }
    this._processRequest(i);
  }
  /**
   * _Private_ function to get a stanza out of a request.
   * Tries to extract a stanza out of a Request Object.
   * When this fails the current connection will be disconnected.
   *
   * @param {Request} req - The Request.
   * @return {Element} - The stanza that was passed.
   */
  _reqToData(req) {
    try {
      return req.getResponse();
    } catch (e) {
      if (e.message !== "parsererror") {
        throw e;
      }
      this._conn.disconnect("strophe-parsererror");
    }
  }
  /**
   * _Private_ function to send initial disconnect sequence.
   *
   * This is the first step in a graceful disconnect.  It sends
   * the BOSH server a terminate body and includes an unavailable
   * presence if authentication has completed.
   * @private
   * @param {Element|Builder} [pres]
   */
  _sendTerminate(pres) {
    log_default.debug("_sendTerminate was called");
    const body = this._buildBody().attrs({ type: "terminate" });
    const el = pres instanceof builder_default ? pres.tree() : pres;
    if (pres) {
      body.cnode(el);
    }
    const req = new request_default(
      body.tree(),
      this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
      Number(body.tree().getAttribute("rid"))
    );
    this._requests.push(req);
    this._throttledRequestHandler();
  }
  /**
   * _Private_ part of the Connection.send function for BOSH
   * Just triggers the RequestHandler to send the messages that are in the queue
   */
  _send() {
    clearTimeout(this._conn._idleTimeout);
    this._throttledRequestHandler();
    this._conn._idleTimeout = setTimeout(() => this._conn._onIdle(), 100);
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    this._throttledRequestHandler();
    clearTimeout(this._conn._idleTimeout);
  }
  /**
   * _Private_ function to throttle requests to the connection window.
   *
   * This function makes sure we don't send requests so fast that the
   * request ids overflow the connection window in the case that one
   * request died.
   * @private
   */
  _throttledRequestHandler() {
    if (!this._requests) {
      log_default.debug("_throttledRequestHandler called with undefined requests");
    } else {
      log_default.debug("_throttledRequestHandler called with " + this._requests.length + " requests");
    }
    if (!this._requests || this._requests.length === 0) {
      return;
    }
    if (this._requests.length > 0) {
      this._processRequest(0);
    }
    if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
      this._processRequest(1);
    }
  }
};
var bosh_default = Bosh;

// node_modules/strophe.js/src/connection.js
var import_abab = __toESM(require_abab());

// node_modules/strophe.js/src/handler.js
var Handler = class {
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Create and initialize a new Handler.
   *
   * @param {Function} handler - A function to be executed when the handler is run.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The element name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The element id attribute to match.
   * @param {string} [from] - The element from attribute to match.
   * @param {HandlerOptions} [options] - Handler options
   */
  constructor(handler, ns, name, type, id, from, options) {
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || { "matchBareFromJid": false, "ignoreNamespaceFragment": false };
    if (this.options.matchBareFromJid) {
      this.from = from ? getBareJidFromJid(from) : null;
    } else {
      this.from = from;
    }
    this.user = true;
  }
  /**
   * Returns the XML namespace attribute on an element.
   * If `ignoreNamespaceFragment` was passed in for this handler, then the
   * URL fragment will be stripped.
   * @param {Element} elem - The XML element with the namespace.
   * @return {string} - The namespace, with optionally the fragment stripped.
   */
  getNamespace(elem) {
    let elNamespace = elem.getAttribute("xmlns");
    if (elNamespace && this.options.ignoreNamespaceFragment) {
      elNamespace = elNamespace.split("#")[0];
    }
    return elNamespace;
  }
  /**
   * Tests if a stanza matches the namespace set for this Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  namespaceMatch(elem) {
    let nsMatch = false;
    if (!this.ns) {
      return true;
    } else {
      forEachChild(
        elem,
        null,
        /** @param {Element} elem */
        (elem2) => {
          if (this.getNamespace(elem2) === this.ns) {
            nsMatch = true;
          }
        }
      );
      return nsMatch || this.getNamespace(elem) === this.ns;
    }
  }
  /**
   * Tests if a stanza matches the Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  isMatch(elem) {
    let from = elem.getAttribute("from");
    if (this.options.matchBareFromJid) {
      from = getBareJidFromJid(from);
    }
    const elem_type = elem.getAttribute("type");
    if (this.namespaceMatch(elem) && (!this.name || isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute("id") === this.id) && (!this.from || from === this.from)) {
      return true;
    }
    return false;
  }
  /**
   * Run the callback on a matching stanza.
   * @param {Element} elem - The DOM element that triggered the Handler.
   * @return {boolean} - A boolean indicating if the handler should remain active.
   */
  run(elem) {
    let result = null;
    try {
      result = this.handler(elem);
    } catch (e) {
      handleError(e);
      throw e;
    }
    return result;
  }
  /**
   * Get a String representation of the Handler object.
   * @return {string}
   */
  toString() {
    return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}";
  }
};
var handler_default = Handler;

// node_modules/strophe.js/src/timed-handler.js
var TimedHandler = class {
  /**
   * Create and initialize a new Strophe.TimedHandler object.
   * @param {number} period - The number of milliseconds to wait before the
   *     handler is called.
   * @param {Function} handler - The callback to run when the handler fires.  This
   *     function should take no arguments.
   */
  constructor(period, handler) {
    this.period = period;
    this.handler = handler;
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    this.user = true;
  }
  /**
   * Run the callback for the Strophe.TimedHandler.
   *
   * @return {boolean} Returns the result of running the handler,
   *  which is `true` if the Strophe.TimedHandler should be called again,
   *  and `false` otherwise.
   */
  run() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    return this.handler();
  }
  /**
   * Reset the last called time for the Strophe.TimedHandler.
   */
  reset() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
  }
  /**
   * Get a string representation of the Strophe.TimedHandler object.
   * @return {string}
   */
  toString() {
    return "{TimedHandler: " + this.handler + "(" + this.period + ")}";
  }
};
var timed_handler_default = TimedHandler;

// node_modules/strophe.js/src/sasl.js
var SASLMechanism = class {
  /**
   * PrivateConstructor: Strophe.SASLMechanism
   * SASL auth mechanism abstraction.
   * @param {String} [name] - SASL Mechanism name.
   * @param {Boolean} [isClientFirst] - If client should send response first without challenge.
   * @param {Number} [priority] - Priority.
   */
  constructor(name, isClientFirst, priority) {
    this.mechname = name;
    this.isClientFirst = isClientFirst;
    this.priority = priority;
  }
  /**
   * Checks if mechanism able to run.
   * To disable a mechanism, make this return false;
   *
   * To disable plain authentication run
   * > Strophe.SASLPlain.test = function() {
   * >   return false;
   * > }
   *
   * See <SASL mechanisms> for a list of available mechanisms.
   * @param {Connection} connection - Target Connection.
   * @return {boolean} If mechanism was able to run.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  test(connection) {
    return true;
  }
  /**
   * Called before starting mechanism on some connection.
   * @param {Connection} connection - Target Connection.
   */
  onStart(connection) {
    this._connection = connection;
  }
  /**
   * Called by protocol implementation on incoming challenge.
   *
   * By deafult, if the client is expected to send data first (isClientFirst === true),
   * this method is called with `challenge` as null on the first call,
   * unless `clientChallenge` is overridden in the relevant subclass.
   * @param {Connection} connection - Target Connection.
   * @param {string} [challenge] - current challenge to handle.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  onChallenge(connection, challenge) {
    throw new Error("You should implement challenge handling!");
  }
  /**
   * Called by the protocol implementation if the client is expected to send
   * data first in the authentication exchange (i.e. isClientFirst === true).
   * @param {Connection} connection - Target Connection.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  clientChallenge(connection) {
    if (!this.isClientFirst) {
      throw new Error("clientChallenge should not be called if isClientFirst is false!");
    }
    return this.onChallenge(connection);
  }
  /**
   * Protocol informs mechanism implementation about SASL failure.
   */
  onFailure() {
    this._connection = null;
  }
  /**
   * Protocol informs mechanism implementation about SASL success.
   */
  onSuccess() {
    this._connection = null;
  }
};
var sasl_default = SASLMechanism;

// node_modules/strophe.js/src/sasl-anon.js
var SASLAnonymous = class extends sasl_default {
  /**
   * SASL ANONYMOUS authentication.
   */
  constructor(mechname = "ANONYMOUS", isClientFirst = false, priority = 20) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid === null;
  }
};
var sasl_anon_default = SASLAnonymous;

// node_modules/strophe.js/src/sasl-external.js
var SASLExternal = class extends sasl_default {
  /**
   * SASL EXTERNAL authentication.
   *
   * The EXTERNAL mechanism allows a client to request the server to use
   * credentials established by means external to the mechanism to
   * authenticate the client. The external means may be, for instance,
   * TLS services.
   */
  constructor(mechname = "EXTERNAL", isClientFirst = true, priority = 10) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    return connection.authcid === connection.authzid ? "" : connection.authzid;
  }
};
var sasl_external_default = SASLExternal;

// node_modules/strophe.js/src/sasl-oauthbearer.js
var SASLOAuthBearer = class extends sasl_default {
  /**
   * SASL OAuth Bearer authentication.
   */
  constructor(mechname = "OAUTHBEARER", isClientFirst = true, priority = 40) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "n,";
    if (connection.authcid !== null) {
      auth_str = auth_str + "a=" + connection.authzid;
    }
    auth_str = auth_str + ",";
    auth_str = auth_str + "";
    auth_str = auth_str + "auth=Bearer ";
    auth_str = auth_str + connection.pass;
    auth_str = auth_str + "";
    auth_str = auth_str + "";
    return utils.utf16to8(auth_str);
  }
};
var sasl_oauthbearer_default = SASLOAuthBearer;

// node_modules/strophe.js/src/sasl-plain.js
var SASLPlain = class extends sasl_default {
  /**
   * SASL PLAIN authentication.
   */
  constructor(mechname = "PLAIN", isClientFirst = true, priority = 50) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    const { authcid, authzid, domain, pass } = connection;
    if (!domain) {
      throw new Error("SASLPlain onChallenge: domain is not defined!");
    }
    let auth_str = authzid !== `${authcid}@${domain}` ? authzid : "";
    auth_str = auth_str + "\0";
    auth_str = auth_str + authcid;
    auth_str = auth_str + "\0";
    auth_str = auth_str + pass;
    return utils.utf16to8(auth_str);
  }
};
var sasl_plain_default = SASLPlain;

// node_modules/strophe.js/src/scram.js
async function scramClientProof(authMessage, clientKey, hashName) {
  const storedKey = await crypto.subtle.importKey(
    "raw",
    await crypto.subtle.digest(hashName, clientKey),
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  const clientSignature = await crypto.subtle.sign("HMAC", storedKey, utils.stringToArrayBuf(authMessage));
  return utils.xorArrayBuffers(clientKey, clientSignature);
}
function scramParseChallenge(challenge) {
  let nonce, salt, iter;
  const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
  while (challenge.match(attribMatch)) {
    const matches = challenge.match(attribMatch);
    challenge = challenge.replace(matches[0], "");
    switch (matches[1]) {
      case "r":
        nonce = matches[2];
        break;
      case "s":
        salt = utils.base64ToArrayBuf(matches[2]);
        break;
      case "i":
        iter = parseInt(matches[2], 10);
        break;
      case "m":
        return void 0;
      default:
        break;
    }
  }
  if (isNaN(iter) || iter < 4096) {
    log_default.warn("Failing SCRAM authentication because server supplied iteration count < 4096.");
    return void 0;
  }
  if (!salt) {
    log_default.warn("Failing SCRAM authentication because server supplied incorrect salt.");
    return void 0;
  }
  return { "nonce": nonce, "salt": salt, "iter": iter };
}
async function scramDeriveKeys(password, salt, iter, hashName, hashBits) {
  const saltedPasswordBits = await crypto.subtle.deriveBits(
    { "name": "PBKDF2", "salt": salt, "iterations": iter, "hash": { "name": hashName } },
    await crypto.subtle.importKey("raw", utils.stringToArrayBuf(password), "PBKDF2", false, ["deriveBits"]),
    hashBits
  );
  const saltedPassword = await crypto.subtle.importKey(
    "raw",
    saltedPasswordBits,
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  return {
    "ck": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Client Key")),
    "sk": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Server Key"))
  };
}
async function scramServerSign(authMessage, sk, hashName) {
  const serverKey = await crypto.subtle.importKey("raw", sk, { "name": "HMAC", "hash": hashName }, false, ["sign"]);
  return crypto.subtle.sign("HMAC", serverKey, utils.stringToArrayBuf(authMessage));
}
function generate_cnonce() {
  const bytes = new Uint8Array(16);
  return utils.arrayBufToBase64(crypto.getRandomValues(bytes).buffer);
}
var scram = {
  /**
   * On success, sets
   * connection_sasl_data["server-signature"]
   * and
   * connection._sasl_data.keys
   *
   * The server signature should be verified after this function completes..
   *
   * On failure, returns connection._sasl_failure_cb();
   * @param {Connection} connection
   * @param {string} challenge
   * @param {string} hashName
   * @param {number} hashBits
   */
  async scramResponse(connection, challenge, hashName, hashBits) {
    const cnonce = connection._sasl_data.cnonce;
    const challengeData = scramParseChallenge(challenge);
    if (!challengeData && (challengeData == null ? void 0 : challengeData.nonce.slice(0, cnonce.length)) !== cnonce) {
      log_default.warn("Failing SCRAM authentication because server supplied incorrect nonce.");
      connection._sasl_data = {};
      return connection._sasl_failure_cb();
    }
    let clientKey, serverKey;
    const { pass } = connection;
    if (typeof connection.pass === "string" || connection.pass instanceof String) {
      const keys = await scramDeriveKeys(
        /** @type {string} */
        pass,
        challengeData.salt,
        challengeData.iter,
        hashName,
        hashBits
      );
      clientKey = keys.ck;
      serverKey = keys.sk;
    } else if (
      // Either restore the client key and server key passed in, or derive new ones
      /** @type {Password} */
      (pass == null ? void 0 : pass.name) === hashName && /** @type {Password} */
      (pass == null ? void 0 : pass.salt) === utils.arrayBufToBase64(challengeData.salt) && /** @type {Password} */
      (pass == null ? void 0 : pass.iter) === challengeData.iter
    ) {
      const { ck, sk } = (
        /** @type {Password} */
        pass
      );
      clientKey = utils.base64ToArrayBuf(ck);
      serverKey = utils.base64ToArrayBuf(sk);
    } else {
      return connection._sasl_failure_cb();
    }
    const clientFirstMessageBare = connection._sasl_data["client-first-message-bare"];
    const serverFirstMessage = challenge;
    const clientFinalMessageBare = `c=biws,r=${challengeData.nonce}`;
    const authMessage = `${clientFirstMessageBare},${serverFirstMessage},${clientFinalMessageBare}`;
    const clientProof = await scramClientProof(authMessage, clientKey, hashName);
    const serverSignature = await scramServerSign(authMessage, serverKey, hashName);
    connection._sasl_data["server-signature"] = utils.arrayBufToBase64(serverSignature);
    connection._sasl_data.keys = {
      "name": hashName,
      "iter": challengeData.iter,
      "salt": utils.arrayBufToBase64(challengeData.salt),
      "ck": utils.arrayBufToBase64(clientKey),
      "sk": utils.arrayBufToBase64(serverKey)
    };
    return `${clientFinalMessageBare},p=${utils.arrayBufToBase64(clientProof)}`;
  },
  /**
   * Returns a string containing the client first message
   * @param {Connection} connection
   * @param {string} test_cnonce
   */
  clientChallenge(connection, test_cnonce) {
    const cnonce = test_cnonce || generate_cnonce();
    const client_first_message_bare = `n=${connection.authcid},r=${cnonce}`;
    connection._sasl_data.cnonce = cnonce;
    connection._sasl_data["client-first-message-bare"] = client_first_message_bare;
    return `n,,${client_first_message_bare}`;
  }
};

// node_modules/strophe.js/src/sasl-sha1.js
var SASLSHA1 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 1 authentication.
   */
  constructor(mechname = "SCRAM-SHA-1", isClientFirst = true, priority = 60) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   * @return {Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-1", 160);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha1_default = SASLSHA1;

// node_modules/strophe.js/src/sasl-sha256.js
var SASLSHA256 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 256 authentication.
   */
  constructor(mechname = "SCRAM-SHA-256", isClientFirst = true, priority = 70) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-256", 256);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha256_default = SASLSHA256;

// node_modules/strophe.js/src/sasl-sha384.js
var SASLSHA384 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 384 authentication.
   */
  constructor(mechname = "SCRAM-SHA-384", isClientFirst = true, priority = 71) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-384", 384);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha384_default = SASLSHA384;

// node_modules/strophe.js/src/sasl-sha512.js
var SASLSHA512 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 512 authentication.
   */
  constructor(mechname = "SCRAM-SHA-512", isClientFirst = true, priority = 72) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-512", 512);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha512_default = SASLSHA512;

// node_modules/strophe.js/src/sasl-xoauth2.js
var SASLXOAuth2 = class extends sasl_default {
  /**
   * SASL X-OAuth2 authentication.
   */
  constructor(mechname = "X-OAUTH2", isClientFirst = true, priority = 30) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "\0";
    if (connection.authcid !== null) {
      auth_str = auth_str + connection.authzid;
    }
    auth_str = auth_str + "\0";
    auth_str = auth_str + connection.pass;
    return utils.utf16to8(auth_str);
  }
};
var sasl_xoauth2_default = SASLXOAuth2;

// node_modules/strophe.js/src/errors.js
var SessionError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "StropheSessionError";
  }
};

// node_modules/strophe.js/src/websocket.js
var Websocket = class {
  /**
   * Create and initialize a WebSocket object.
   * Currently only sets the connection Object.
   * @param {Connection} connection - The Connection that will use WebSockets.
   */
  constructor(connection) {
    this._conn = connection;
    this.strip = "wrapper";
    const service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
      let new_service = "";
      if (connection.options.protocol === "ws" && location.protocol !== "https:") {
        new_service += "ws";
      } else {
        new_service += "wss";
      }
      new_service += "://" + location.host;
      if (service.indexOf("/") !== 0) {
        new_service += location.pathname + service;
      } else {
        new_service += service;
      }
      connection.service = new_service;
    }
  }
  /**
   * _Private_ helper function to generate the <stream> start tag for WebSockets
   * @private
   * @return {Builder} - A Builder with a <stream> element.
   */
  _buildStream() {
    return $build("open", {
      "xmlns": NS.FRAMING,
      "to": this._conn.domain,
      "version": "1.0"
    });
  }
  /**
   * _Private_ checks a message for stream:error
   * @private
   * @param {Element} bodyWrap - The received stanza.
   * @param {number} connectstatus - The ConnectStatus that will be set on error.
   * @return {boolean} - true if there was a streamerror, false otherwise.
   */
  _checkStreamError(bodyWrap, connectstatus) {
    let errors;
    if (bodyWrap.getElementsByTagNameNS) {
      errors = bodyWrap.getElementsByTagNameNS(NS.STREAM, "error");
    } else {
      errors = bodyWrap.getElementsByTagName("stream:error");
    }
    if (errors.length === 0) {
      return false;
    }
    const error = errors[0];
    let condition = "";
    let text = "";
    const ns = "urn:ietf:params:xml:ns:xmpp-streams";
    for (let i = 0; i < error.childNodes.length; i++) {
      const e = error.childNodes[i];
      if (e.nodeType === e.ELEMENT_NODE) {
        const el = (
          /** @type {any} */
          e
        );
        if (el.getAttribute("xmlns") !== ns) {
          break;
        }
      }
      if (e.nodeName === "text") {
        text = e.textContent;
      } else {
        condition = e.nodeName;
      }
    }
    let errorString = "WebSocket stream error: ";
    if (condition) {
      errorString += condition;
    } else {
      errorString += "unknown";
    }
    if (text) {
      errorString += " - " + text;
    }
    log_default.error(errorString);
    this._conn._changeConnectStatus(connectstatus, condition);
    this._conn._doDisconnect();
    return true;
  }
  /**
   * Reset the connection.
   *
   * This function is called by the reset function of the Strophe Connection.
   * Is not needed by WebSockets.
   */
  // eslint-disable-next-line class-methods-use-this
  _reset() {
    return;
  }
  /**
   * _Private_ function called by Connection.connect
   *
   * Creates a WebSocket for a connection and assigns Callbacks to it.
   * Does nothing if there already is a WebSocket.
   */
  _connect() {
    this._closeSocket();
    this.socket = new WebSocket(this._conn.service, "xmpp");
    this.socket.onopen = () => this._onOpen();
    this.socket.onerror = (e) => this._onError(e);
    this.socket.onclose = (e) => this._onClose(e);
    this.socket.onmessage = (message) => this._onInitialMessage(message);
  }
  /**
   * _Private_ function called by Connection._connect_cb
   * checks for stream:error
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const error = this._checkStreamError(bodyWrap, Status.CONNFAIL);
    if (error) {
      return Status.CONNFAIL;
    }
  }
  /**
   * _Private_ function that checks the opening <open /> tag for errors.
   *
   * Disconnects if there is an error and returns false, true otherwise.
   * @private
   * @param {Element} message - Stanza containing the <open /> tag.
   */
  _handleStreamStart(message) {
    let error = null;
    const ns = message.getAttribute("xmlns");
    if (typeof ns !== "string") {
      error = "Missing xmlns in <open />";
    } else if (ns !== NS.FRAMING) {
      error = "Wrong xmlns in <open />: " + ns;
    }
    const ver = message.getAttribute("version");
    if (typeof ver !== "string") {
      error = "Missing version in <open />";
    } else if (ver !== "1.0") {
      error = "Wrong version in <open />: " + ver;
    }
    if (error) {
      this._conn._changeConnectStatus(Status.CONNFAIL, error);
      this._conn._doDisconnect();
      return false;
    }
    return true;
  }
  /**
   * _Private_ function that handles the first connection messages.
   *
   * On receiving an opening stream tag this callback replaces itself with the real
   * message handler. On receiving a stream error the connection is terminated.
   * @param {MessageEvent} message
   */
  _onInitialMessage(message) {
    if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
      const data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
      if (data === "") return;
      const streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
      this._conn.xmlInput(streamStart);
      this._conn.rawInput(message.data);
      if (this._handleStreamStart(streamStart)) {
        this._connect_cb(streamStart);
      }
    } else if (message.data.indexOf("<close ") === 0) {
      const parsedMessage = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
      this._conn.xmlInput(parsedMessage);
      this._conn.rawInput(message.data);
      const see_uri = parsedMessage.getAttribute("see-other-uri");
      if (see_uri) {
        const service = this._conn.service;
        const isSecureRedirect = service.indexOf("wss:") >= 0 && see_uri.indexOf("wss:") >= 0 || service.indexOf("ws:") >= 0;
        if (isSecureRedirect) {
          this._conn._changeConnectStatus(
            Status.REDIRECT,
            "Received see-other-uri, resetting connection"
          );
          this._conn.reset();
          this._conn.service = see_uri;
          this._connect();
        }
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "Received closing stream");
        this._conn._doDisconnect();
      }
    } else {
      this._replaceMessageHandler();
      const string = this._streamWrap(message.data);
      const elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
      this._conn._connect_cb(elem, null, message.data);
    }
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this.socket.onmessage = (m) => this._onMessage(m);
  }
  /**
   * _Private_ function called by Connection.disconnect
   * Disconnects and sends a last stanza if one is given
   * @param {Element|Builder} [pres] - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
      if (pres) {
        this._conn.send(pres);
      }
      const close = $build("close", { "xmlns": NS.FRAMING });
      this._conn.xmlOutput(close.tree());
      const closeString = builder_default.serialize(close);
      this._conn.rawOutput(closeString);
      try {
        this.socket.send(closeString);
      } catch (e) {
        log_default.warn("Couldn't send <close /> tag.");
      }
    }
    setTimeout(() => this._conn._doDisconnect(), 0);
  }
  /**
   * _Private_ function to disconnect.
   * Just closes the Socket for WebSockets
   */
  _doDisconnect() {
    log_default.debug("WebSockets _doDisconnect was called");
    this._closeSocket();
  }
  /**
   * PrivateFunction _streamWrap
   * _Private_ helper function to wrap a stanza in a <stream> tag.
   * This is used so Strophe can process stanzas from WebSockets like BOSH
   * @param {string} stanza
   */
  // eslint-disable-next-line class-methods-use-this
  _streamWrap(stanza) {
    return "<wrapper>" + stanza + "</wrapper>";
  }
  /**
   * _Private_ function to close the WebSocket.
   *
   * Closes the socket if it is still open and deletes it
   */
  _closeSocket() {
    if (this.socket) {
      try {
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;
        this.socket.close();
      } catch (e) {
        log_default.debug(e.message);
      }
    }
    this.socket = null;
  }
  /**
   * _Private_ function to check if the message queue is empty.
   * @return {true} - True, because WebSocket messages are send immediately after queueing.
   */
  // eslint-disable-next-line class-methods-use-this
  _emptyQueue() {
    return true;
  }
  /**
   * _Private_ function to handle websockets closing.
   * @param {CloseEvent} [e]
   */
  _onClose(e) {
    if (this._conn.connected && !this._conn.disconnecting) {
      log_default.error("Websocket closed unexpectedly");
      this._conn._doDisconnect();
    } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
      log_default.error("Websocket closed unexcectedly");
      this._conn._changeConnectStatus(
        Status.CONNFAIL,
        "The WebSocket connection could not be established or was disconnected."
      );
      this._conn._doDisconnect();
    } else {
      log_default.debug("Websocket closed");
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log_default.error("Server did not offer a supported authentication mechanism");
    this._conn._changeConnectStatus(Status.CONNFAIL, ErrorCondition.NO_AUTH_MECH);
    callback == null ? void 0 : callback.call(this._conn);
    this._conn._doDisconnect();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * This does nothing for WebSockets
   */
  _onDisconnectTimeout() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ function to handle websockets errors.
   * @param {Object} error - The websocket error.
   */
  _onError(error) {
    log_default.error("Websocket error " + JSON.stringify(error));
    this._conn._changeConnectStatus(
      Status.CONNFAIL,
      "The WebSocket connection could not be established or was disconnected."
    );
    this._disconnect();
  }
  /**
   * _Private_ function called by Connection._onIdle
   * sends all queued stanzas
   */
  _onIdle() {
    const data = this._conn._data;
    if (data.length > 0 && !this._conn.paused) {
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          const stanza = data[i] === "restart" ? this._buildStream().tree() : data[i];
          if (stanza === "restart") throw new Error("Wrong type for stanza");
          const rawStanza = builder_default.serialize(stanza);
          this._conn.xmlOutput(stanza);
          this._conn.rawOutput(rawStanza);
          this.socket.send(rawStanza);
        }
      }
      this._conn._data = [];
    }
  }
  /**
   * _Private_ function to handle websockets messages.
   *
   * This function parses each of the messages as if they are full documents.
   * [TODO : We may actually want to use a SAX Push parser].
   *
   * Since all XMPP traffic starts with
   * <stream:stream version='1.0'
   *                xml:lang='en'
   *                xmlns='jabber:client'
   *                xmlns:stream='http://etherx.jabber.org/streams'
   *                id='3697395463'
   *                from='SERVER'>
   *
   * The first stanza will always fail to be parsed.
   *
   * Additionally, the seconds stanza will always be <stream:features> with
   * the stream NS defined in the previous stanza, so we need to 'force'
   * the inclusion of the NS in this stanza.
   *
   * @param {MessageEvent} message - The websocket message event
   */
  _onMessage(message) {
    let elem;
    const close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
    if (message.data === close) {
      this._conn.rawInput(close);
      this._conn.xmlInput(message);
      if (!this._conn.disconnecting) {
        this._conn._doDisconnect();
      }
      return;
    } else if (message.data.search("<open ") === 0) {
      elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
      if (!this._handleStreamStart(elem)) {
        return;
      }
    } else {
      const data = this._streamWrap(message.data);
      elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
    }
    if (this._checkStreamError(elem, Status.ERROR)) {
      return;
    }
    if (this._conn.disconnecting && elem.firstElementChild.nodeName === "presence" && elem.firstElementChild.getAttribute("type") === "unavailable") {
      this._conn.xmlInput(elem);
      this._conn.rawInput(builder_default.serialize(elem));
      return;
    }
    this._conn._dataRecv(elem, message.data);
  }
  /**
   * _Private_ function to handle websockets connection setup.
   * The opening stream tag is sent here.
   * @private
   */
  _onOpen() {
    log_default.debug("Websocket open");
    const start = this._buildStream();
    this._conn.xmlOutput(start.tree());
    const startString = builder_default.serialize(start);
    this._conn.rawOutput(startString);
    this.socket.send(startString);
  }
  /**
   * _Private_ part of the Connection.send function for WebSocket
   * Just flushes the messages that are in the queue
   */
  _send() {
    this._conn.flush();
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    clearTimeout(this._conn._idleTimeout);
    this._conn._onIdle.bind(this._conn)();
  }
};
var websocket_default = Websocket;

// node_modules/strophe.js/src/worker-websocket.js
var WorkerWebsocket = class extends websocket_default {
  /**
   * @typedef {import("./connection.js").default} Connection
   */
  /**
   * Create and initialize a WorkerWebsocket object.
   * @param {Connection} connection - The Connection
   */
  constructor(connection) {
    super(connection);
    this._conn = connection;
    this.worker = new SharedWorker(this._conn.options.worker, "Strophe XMPP Connection");
    this.worker.onerror = (e) => {
      console == null ? void 0 : console.error(e);
      log_default.error(`Shared Worker Error: ${e}`);
    };
  }
  /**
   * @private
   */
  _setSocket() {
    this.socket = {
      /** @param {string} str */
      send: (str) => this.worker.port.postMessage(["send", str]),
      close: () => this.worker.port.postMessage(["_closeSocket"]),
      onopen: () => {
      },
      /** @param {ErrorEvent} e */
      onerror: (e) => this._onError(e),
      /** @param {CloseEvent} e */
      onclose: (e) => this._onClose(e),
      onmessage: () => {
      },
      readyState: null
    };
  }
  _connect() {
    this._setSocket();
    this._messageHandler = (m) => this._onInitialMessage(m);
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_connect", this._conn.service, this._conn.jid]);
  }
  /**
   * @param {Function} callback
   */
  _attach(callback) {
    this._setSocket();
    this._messageHandler = (m) => this._onMessage(m);
    this._conn.connect_callback = callback;
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_attach", this._conn.service]);
  }
  /**
   * @param {number} status
   * @param {string} jid
   */
  _attachCallback(status, jid) {
    if (status === Status.ATTACHED) {
      this._conn.jid = jid;
      this._conn.authenticated = true;
      this._conn.connected = true;
      this._conn.restored = true;
      this._conn._changeConnectStatus(Status.ATTACHED);
    } else if (status === Status.ATTACHFAIL) {
      this._conn.authenticated = false;
      this._conn.connected = false;
      this._conn.restored = false;
      this._conn._changeConnectStatus(Status.ATTACHFAIL);
    }
  }
  /**
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    pres && this._conn.send(pres);
    const close = $build("close", { "xmlns": NS.FRAMING });
    this._conn.xmlOutput(close.tree());
    const closeString = builder_default.serialize(close);
    this._conn.rawOutput(closeString);
    this.worker.port.postMessage(["send", closeString]);
    this._conn._doDisconnect();
  }
  _closeSocket() {
    this.socket.close();
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this._messageHandler = (m) => this._onMessage(m);
  }
  /**
   * function that handles messages received from the service worker
   * @private
   * @param {MessageEvent} ev
   */
  _onWorkerMessage(ev) {
    const { data } = ev;
    const method_name = data[0];
    if (method_name === "_onMessage") {
      this._messageHandler(data[1]);
    } else if (method_name in this) {
      try {
        this[
          /** @type {'_attachCallback'|'_onOpen'|'_onClose'|'_onError'} */
          method_name
        ].apply(this, ev.data.slice(1));
      } catch (e) {
        log_default.error(e);
      }
    } else if (method_name === "log") {
      const lmap = {
        debug: LOG_LEVELS.DEBUG,
        info: LOG_LEVELS.INFO,
        warn: LOG_LEVELS.WARN,
        error: LOG_LEVELS.ERROR,
        fatal: LOG_LEVELS.FATAL
      };
      const level = data[1];
      const msg = data[2];
      log_default.log(lmap[level], msg);
    } else {
      log_default.error(`Found unhandled service worker message: ${data}`);
    }
  }
};
var worker_websocket_default = WorkerWebsocket;

// node_modules/strophe.js/src/connection.js
var connectionPlugins = {};
var Connection = class _Connection {
  /**
   * @typedef {Object.<string, string>} Cookie
   * @typedef {Cookie|Object.<string, Cookie>} Cookies
   */
  /**
   * @typedef {Object} ConnectionOptions
   * @property {Cookies} [cookies]
   *  Allows you to pass in cookies that will be included in HTTP requests.
   *  Relevant to both the BOSH and Websocket transports.
   *
   *  The passed in value must be a map of cookie names and string values.
   *
   *  > { "myCookie": {
   *  >     "value": "1234",
   *  >     "domain": ".example.org",
   *  >     "path": "/",
   *  >     "expires": expirationDate
   *  >     }
   *  > }
   *
   *  Note that cookies can't be set in this way for domains other than the one
   *  that's hosting Strophe (i.e. cross-domain).
   *  Those cookies need to be set under those domains, for example they can be
   *  set server-side by making a XHR call to that domain to ask it to set any
   *  necessary cookies.
   * @property {SASLMechanism[]} [mechanisms]
   *  Allows you to specify the SASL authentication mechanisms that this
   *  instance of Connection (and therefore your XMPP client) will support.
   *
   *  The value must be an array of objects with {@link SASLMechanism}
   *  prototypes.
   *
   *  If nothing is specified, then the following mechanisms (and their
   *  priorities) are registered:
   *
   *      Mechanism       Priority
   *      ------------------------
   *      SCRAM-SHA-512   72
   *      SCRAM-SHA-384   71
   *      SCRAM-SHA-256   70
   *      SCRAM-SHA-1     60
   *      PLAIN           50
   *      OAUTHBEARER     40
   *      X-OAUTH2        30
   *      ANONYMOUS       20
   *      EXTERNAL        10
   *
   * @property {boolean} [explicitResourceBinding]
   *  If `explicitResourceBinding` is set to `true`, then the XMPP client
   *  needs to explicitly call {@link Connection.bind} once the XMPP
   *  server has advertised the `urn:ietf:propertys:xml:ns:xmpp-bind` feature.
   *
   *  Making this step explicit allows client authors to first finish other
   *  stream related tasks, such as setting up an XEP-0198 Stream Management
   *  session, before binding the JID resource for this session.
   *
   * @property {'ws'|'wss'} [protocol]
   *  _Note: This option is only relevant to Websocket connections, and not BOSH_
   *
   *  If you want to connect to the current host with a WebSocket connection you
   *  can tell Strophe to use WebSockets through the "protocol" option.
   *  Valid values are `ws` for WebSocket and `wss` for Secure WebSocket.
   *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
   *
   *      const conn = new Strophe.Connection(
   *          "/xmpp-websocket/",
   *          {protocol: "wss"}
   *      );
   *
   *  Note that relative URLs _NOT_ starting with a "/" will also include the path
   *  of the current site.
   *
   *  Also because downgrading security is not permitted by browsers, when using
   *  relative URLs both BOSH and WebSocket connections will use their secure
   *  variants if the current connection to the site is also secure (https).
   *
   * @property {string} [worker]
   *  _Note: This option is only relevant to Websocket connections, and not BOSH_
   *
   *  Set this option to URL from where the shared worker script should be loaded.
   *
   *  To run the websocket connection inside a shared worker.
   *  This allows you to share a single websocket-based connection between
   *  multiple Connection instances, for example one per browser tab.
   *
   *  The script to use is the one in `src/shared-connection-worker.js`.
   *
   * @property {boolean} [sync]
   *  Used to control whether BOSH HTTP requests will be made synchronously or not.
   *  The default behaviour is asynchronous. If you want to make requests
   *  synchronous, make "sync" evaluate to true.
   *
   *  > const conn = new Strophe.Connection("/http-bind/", {sync: true});
   *
   *  You can also toggle this on an already established connection.
   *
   *  > conn.options.sync = true;
   *
   * @property {string[]} [customHeaders]
   *  Used to provide custom HTTP headers to be included in the BOSH HTTP requests.
   *
   * @property {boolean} [keepalive]
   *  Used to instruct Strophe to maintain the current BOSH session across
   *  interruptions such as webpage reloads.
   *
   *  It will do this by caching the sessions tokens in sessionStorage, and when
   *  "restore" is called it will check whether there are cached tokens with
   *  which it can resume an existing session.
   *
   * @property {boolean} [withCredentials]
   *  Used to indicate wether cookies should be included in HTTP requests (by default
   *  they're not).
   *  Set this value to `true` if you are connecting to a BOSH service
   *  and for some reason need to send cookies to it.
   *  In order for this to work cross-domain, the server must also enable
   *  credentials by setting the `Access-Control-Allow-Credentials` response header
   *  to "true". For most usecases however this setting should be false (which
   *  is the default).
   *  Additionally, when using `Access-Control-Allow-Credentials`, the
   *  `Access-Control-Allow-Origin` header can't be set to the wildcard "*", but
   *  instead must be restricted to actual domains.
   *
   * @property {string} [contentType]
   *  Used to change the default Content-Type, which is "text/xml; charset=utf-8".
   *  Can be useful to reduce the amount of CORS preflight requests that are sent
   *  to the server.
   */
  /**
   * Create and initialize a {@link Connection} object.
   *
   * The transport-protocol for this connection will be chosen automatically
   * based on the given service parameter. URLs starting with "ws://" or
   * "wss://" will use WebSockets, URLs starting with "http://", "https://"
   * or without a protocol will use [BOSH](https://xmpp.org/extensions/xep-0124.html).
   *
   * To make Strophe connect to the current host you can leave out the protocol
   * and host part and just pass the path:
   *
   *  const conn = new Strophe.Connection("/http-bind/");
   *
   * @param {string} service - The BOSH or WebSocket service URL.
   * @param {ConnectionOptions} options - A object containing configuration options
   */
  constructor(service, options = {}) {
    this.service = service;
    this.options = options;
    this.setProtocol();
    this.jid = "";
    this.domain = null;
    this.features = null;
    this._sasl_data = {};
    this.do_bind = false;
    this.do_session = false;
    this.mechanisms = {};
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.protocolErrorHandlers = {
      /** @type {Object.<number, Function>} */
      "HTTP": {},
      /** @type {Object.<number, Function>} */
      "websocket": {}
    };
    this._idleTimeout = null;
    this._disconnectTimeout = null;
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.do_authentication = true;
    this.paused = false;
    this.restored = false;
    this._data = [];
    this._uniqueId = 0;
    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;
    this.maxRetries = 5;
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    addCookies(this.options.cookies);
    this.registerSASLMechanisms(this.options.mechanisms);
    this.iqFallbackHandler = new handler_default(
      /**
       * @param {Element} iq
       */
      (iq) => this.send(
        $iq({ type: "error", id: iq.getAttribute("id") }).c("error", { "type": "cancel" }).c("service-unavailable", { "xmlns": NS.STANZAS })
      ),
      null,
      "iq",
      ["get", "set"]
    );
    for (const k in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k)) {
        const F = function() {
        };
        F.prototype = connectionPlugins[k];
        this[k] = new F();
        this[k].init(this);
      }
    }
  }
  /**
   * Extends the Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  static addConnectionPlugin(name, ptype) {
    connectionPlugins[name] = ptype;
  }
  /**
   * Select protocal based on this.options or this.service
   */
  setProtocol() {
    const proto = this.options.protocol || "";
    if (this.options.worker) {
      this._proto = new worker_websocket_default(this);
    } else if (this.service.indexOf("ws:") === 0 || this.service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
      this._proto = new websocket_default(this);
    } else {
      this._proto = new bosh_default(this);
    }
  }
  /**
   * Reset the connection.
   *
   * This function should be called after a connection is disconnected
   * before that connection is reused.
   */
  reset() {
    this._proto._reset();
    this.do_session = false;
    this.do_bind = false;
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.restored = false;
    this._data = [];
    this._requests = [];
    this._uniqueId = 0;
  }
  /**
   * Pause the request manager.
   *
   * This will prevent Strophe from sending any more requests to the
   * server.  This is very useful for temporarily pausing
   * BOSH-Connections while a lot of send() calls are happening quickly.
   * This causes Strophe to send the data in a single request, saving
   * many request trips.
   */
  pause() {
    this.paused = true;
  }
  /**
   * Resume the request manager.
   *
   * This resumes after pause() has been called.
   */
  resume() {
    this.paused = false;
  }
  /**
   * Generate a unique ID for use in <iq/> elements.
   *
   * All <iq/> stanzas are required to have unique id attributes.  This
   * function makes creating these easy.  Each connection instance has
   * a counter which starts from zero, and the value of this counter
   * plus a colon followed by the suffix becomes the unique id. If no
   * suffix is supplied, the counter is used as the unique id.
   *
   * Suffixes are used to make debugging easier when reading the stream
   * data, and their use is recommended.  The counter resets to 0 for
   * every new connection for the same reason.  For connections to the
   * same server that authenticate the same way, all the ids should be
   * the same, which makes it easy to see changes.  This is useful for
   * automated testing as well.
   *
   * @param {string} suffix - A optional suffix to append to the id.
   * @returns {string} A unique string to be used for the id attribute.
   */
  // eslint-disable-next-line class-methods-use-this
  getUniqueId(suffix) {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    if (typeof suffix === "string" || typeof suffix === "number") {
      return uuid + ":" + suffix;
    } else {
      return uuid + "";
    }
  }
  /**
   * Register a handler function for when a protocol (websocker or HTTP)
   * error occurs.
   *
   * NOTE: Currently only HTTP errors for BOSH requests are handled.
   * Patches that handle websocket errors would be very welcome.
   *
   * @example
   *  function onError(err_code){
   *    //do stuff
   *  }
   *
   *  const conn = Strophe.connect('http://example.com/http-bind');
   *  conn.addProtocolErrorHandler('HTTP', 500, onError);
   *  // Triggers HTTP 500 error and onError handler will be called
   *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
   *
   * @param {'HTTP'|'websocket'} protocol - 'HTTP' or 'websocket'
   * @param {number} status_code - Error status code (e.g 500, 400 or 404)
   * @param {Function} callback - Function that will fire on Http error
   */
  addProtocolErrorHandler(protocol, status_code, callback) {
    this.protocolErrorHandlers[protocol][status_code] = callback;
  }
  /**
   * @typedef {Object} Password
   * @property {string} Password.name
   * @property {string} Password.ck
   * @property {string} Password.sk
   * @property {number} Password.iter
   * @property {string} Password.salt
   */
  /**
   * Starts the connection process.
   *
   * As the connection process proceeds, the user supplied callback will
   * be triggered multiple times with status updates.  The callback
   * should take two arguments - the status code and the error condition.
   *
   * The status code will be one of the values in the Strophe.Status
   * constants.  The error condition will be one of the conditions
   * defined in RFC 3920 or the condition 'strophe-parsererror'.
   *
   * The Parameters _wait_, _hold_ and _route_ are optional and only relevant
   * for BOSH connections. Please see XEP 124 for a more detailed explanation
   * of the optional parameters.
   *
   * @param {string} jid - The user's JID.  This may be a bare JID,
   *     or a full JID.  If a node is not supplied, SASL OAUTHBEARER or
   *     SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will
   *     process the provided password value as an access token).
   *   (String or Object) pass - The user's password, or an object containing
   *     the users SCRAM client and server keys, in a fashion described as follows:
   *
   *     { name: String, representing the hash used (eg. SHA-1),
   *       salt: String, base64 encoded salt used to derive the client key,
   *       iter: Int,    the iteration count used to derive the client key,
   *       ck:   String, the base64 encoding of the SCRAM client key
   *       sk:   String, the base64 encoding of the SCRAM server key
   *     }
   * @param {string|Password} pass - The user password
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} [route] - The optional route value.
   * @param {string} [authcid] - The optional alternative authentication identity
   *     (username) if intending to impersonate another user.
   *     When using the SASL-EXTERNAL authentication mechanism, for example
   *     with client certificates, then the authcid value is used to
   *     determine whether an authorization JID (authzid) should be sent to
   *     the server. The authzid should NOT be sent to the server if the
   *     authzid and authcid are the same. So to prevent it from being sent
   *     (for example when the JID is already contained in the client
   *     certificate), set authcid to that same JID. See XEP-178 for more
   *     details.
   *  @param {number} [disconnection_timeout=3000] - The optional disconnection timeout
   *     in milliseconds before _doDisconnect will be called.
   */
  connect(jid, pass, callback, wait, hold, route, authcid, disconnection_timeout = 3e3) {
    this.jid = jid;
    this.authzid = getBareJidFromJid(this.jid);
    this.authcid = authcid || getNodeFromJid(this.jid);
    this.pass = pass;
    this.scram_keys = null;
    this.connect_callback = callback;
    this.disconnecting = false;
    this.connected = false;
    this.authenticated = false;
    this.restored = false;
    this.disconnection_timeout = disconnection_timeout;
    this.domain = getDomainFromJid(this.jid);
    this._changeConnectStatus(Status.CONNECTING, null);
    this._proto._connect(wait, hold, route);
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string|Function} jid - The full JID that is bound by the session.
   * @param {string} [sid] - The SID of the BOSH session.
   * @param {number} [rid] - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} [callback] - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  attach(jid, sid, rid, callback, wait, hold, wind) {
    if (this._proto instanceof bosh_default && typeof jid === "string") {
      return this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
    } else if (this._proto instanceof worker_websocket_default && typeof jid === "function") {
      const callback2 = jid;
      return this._proto._attach(callback2);
    } else {
      throw new SessionError('The "attach" method is not available for your connection protocol');
    }
  }
  /**
   * Attempt to restore a cached BOSH session.
   *
   * This function is only useful in conjunction with providing the
   * "keepalive":true option when instantiating a new {@link Connection}.
   *
   * When "keepalive" is set to true, Strophe will cache the BOSH tokens
   * RID (Request ID) and SID (Session ID) and then when this function is
   * called, it will attempt to restore the session from those cached
   * tokens.
   *
   * This function must therefore be called instead of connect or attach.
   *
   * For an example on how to use it, please see examples/restore.js
   *
   * @param {string} jid - The user's JID.  This may be a bare JID or a full JID.
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  restore(jid, callback, wait, hold, wind) {
    if (!(this._proto instanceof bosh_default) || !this._sessionCachingSupported()) {
      throw new SessionError('The "restore" method can only be used with a BOSH connection.');
    }
    if (this._sessionCachingSupported()) {
      this._proto._restore(jid, callback, wait, hold, wind);
    }
  }
  /**
   * Checks whether sessionStorage and JSON are supported and whether we're
   * using BOSH.
   */
  _sessionCachingSupported() {
    if (this._proto instanceof bosh_default) {
      if (!JSON) {
        return false;
      }
      try {
        sessionStorage.setItem("_strophe_", "_strophe_");
        sessionStorage.removeItem("_strophe_");
      } catch (e) {
        return false;
      }
      return true;
    }
    return false;
  }
  /**
   * User overrideable function that receives XML data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlInput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Node|MessageEvent} elem - The XML data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlInput(elem) {
    return;
  }
  /**
   * User overrideable function that receives XML data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlOutput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Element} elem - The XMLdata sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlOutput(elem) {
    return;
  }
  /**
   * User overrideable function that receives raw data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawInput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawInput(data) {
    return;
  }
  /**
   * User overrideable function that receives raw data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawOutput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawOutput(data) {
    return;
  }
  /**
   * User overrideable function that receives the new valid rid.
   *
   * The default function does nothing. User code can override this with
   * > Connection.nextValidRid = function (rid) {
   * >    (user code)
   * > };
   *
   * @param {number} rid - The next valid rid
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  nextValidRid(rid) {
    return;
  }
  /**
   * Send a stanza.
   *
   * This function is called to push data onto the send queue to
   * go out over the wire.  Whenever a request is sent to the BOSH
   * server, all pending data is sent and the queue is flushed.
   *
   * @param {Element|Builder|Element[]|Builder[]} stanza - The stanza to send
   */
  send(stanza) {
    if (stanza === null) return;
    if (Array.isArray(stanza)) {
      stanza.forEach((s) => this._queueData(s instanceof builder_default ? s.tree() : s));
    } else {
      const el = stanza instanceof builder_default ? stanza.tree() : stanza;
      this._queueData(el);
    }
    this._proto._send();
  }
  /**
   * Immediately send any pending outgoing data.
   *
   * Normally send() queues outgoing data until the next idle period
   * (100ms), which optimizes network use in the common cases when
   * several send()s are called in succession. flush() can be used to
   * immediately send all pending data.
   */
  flush() {
    clearTimeout(this._idleTimeout);
    this._onIdle();
  }
  /**
   * Helper function to send presence stanzas. The main benefit is for
   * sending presence stanzas for which you expect a responding presence
   * stanza with the same id (for example when leaving a chat room).
   *
   * @param {Element} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *    out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *    timeout to occur.
   * @return {string} The id used to send the presence.
   */
  sendPresence(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof builder_default ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendPresence");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          if (stanza2.getAttribute("type") === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else if (callback) {
            callback(stanza2);
          }
        },
        null,
        "presence",
        null,
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Helper function to send IQ stanzas.
   *
   * @param {Element|Builder} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *     out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *     timeout to occur.
   * @return {string} The id used to send the IQ.
   */
  sendIQ(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof builder_default ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendIQ");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          const iqtype = stanza2.getAttribute("type");
          if (iqtype === "result") {
            callback == null ? void 0 : callback(stanza2);
          } else if (iqtype === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else {
            const error = new Error(`Got bad IQ type of ${iqtype}`);
            error.name = "StropheError";
            throw error;
          }
        },
        null,
        "iq",
        ["error", "result"],
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Queue outgoing data for later sending.  Also ensures that the data
   * is a DOMElement.
   * @private
   * @param {Element} element
   */
  _queueData(element) {
    if (element === null || !element.tagName || !element.childNodes) {
      const error = new Error("Cannot queue non-DOMElement.");
      error.name = "StropheError";
      throw error;
    }
    this._data.push(element);
  }
  /**
   * Send an xmpp:restart stanza.
   * @private
   */
  _sendRestart() {
    this._data.push("restart");
    this._proto._sendRestart();
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
  }
  /**
   * Add a timed handler to the connection.
   *
   * This function adds a timed handler.  The provided handler will
   * be called every period milliseconds until it returns false,
   * the connection is terminated, or the handler is removed.  Handlers
   * that wish to continue being invoked should return true.
   *
   * Because of method binding it is necessary to save the result of
   * this function if you wish to remove a handler with
   * deleteTimedHandler().
   *
   * Note that user handlers are not active until authentication is
   * successful.
   *
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   * @return {TimedHandler} A reference to the handler that can be used to remove it.
   */
  addTimedHandler(period, handler) {
    const thand = new timed_handler_default(period, handler);
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * Delete a timed handler for a connection.
   *
   * This function removes a timed handler from the connection.  The
   * handRef parameter is *not* the function passed to addTimedHandler(),
   * but is the reference returned from addTimedHandler().
   * @param {TimedHandler} handRef - The handler reference.
   */
  deleteTimedHandler(handRef) {
    this.removeTimeds.push(handRef);
  }
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Add a stanza handler for the connection.
   *
   * This function adds a stanza handler to the connection.  The
   * handler callback will be called for any stanza that matches
   * the parameters.  Note that if multiple parameters are supplied,
   * they must all match for the handler to be invoked.
   *
   * The handler will receive the stanza that triggered it as its argument.
   * *The handler should return true if it is to be invoked again;
   * returning false will remove the handler after it returns.*
   *
   * As a convenience, the ns parameters applies to the top level element
   * and also any of its immediate children.  This is primarily to make
   * matching /iq/query elements easy.
   *
   * ### Options
   *
   * With the options argument, you can specify boolean flags that affect how
   * matches are being done.
   *
   * Currently two flags exist:
   *
   * * *matchBareFromJid*:
   *     When set to true, the from parameter and the
   *     from attribute on the stanza will be matched as bare JIDs instead
   *     of full JIDs. To use this, pass {matchBareFromJid: true} as the
   *     value of options. The default value for matchBareFromJid is false.
   *
   * * *ignoreNamespaceFragment*:
   *     When set to true, a fragment specified on the stanza's namespace
   *     URL will be ignored when it's matched with the one configured for
   *     the handler.
   *
   *     This means that if you register like this:
   *
   *     >   connection.addHandler(
   *     >       handler,
   *     >       'http://jabber.org/protocol/muc',
   *     >       null, null, null, null,
   *     >       {'ignoreNamespaceFragment': true}
   *     >   );
   *
   *     Then a stanza with XML namespace of
   *     'http://jabber.org/protocol/muc#user' will also be matched. If
   *     'ignoreNamespaceFragment' is false, then only stanzas with
   *     'http://jabber.org/protocol/muc' will be matched.
   *
   * ### Deleting the handler
   *
   * The return value should be saved if you wish to remove the handler
   * with `deleteHandler()`.
   *
   * @param {Function} handler - The user callback.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The stanza id attribute to match.
   * @param {string} [from] - The stanza from attribute to match.
   * @param {HandlerOptions} [options] - The handler options
   * @return {Handler} A reference to the handler that can be used to remove it.
   */
  addHandler(handler, ns, name, type, id, from, options) {
    const hand = new handler_default(handler, ns, name, type, id, from, options);
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * Delete a stanza handler for a connection.
   *
   * This function removes a stanza handler from the connection.  The
   * handRef parameter is *not* the function passed to addHandler(),
   * but is the reference returned from addHandler().
   *
   * @param {Handler} handRef - The handler reference.
   */
  deleteHandler(handRef) {
    this.removeHandlers.push(handRef);
    const i = this.addHandlers.indexOf(handRef);
    if (i >= 0) {
      this.addHandlers.splice(i, 1);
    }
  }
  /**
   * Register the SASL mechanisms which will be supported by this instance of
   * Connection (i.e. which this XMPP client will support).
   * @param {SASLMechanism[]} mechanisms - Array of objects with SASLMechanism prototypes
   */
  registerSASLMechanisms(mechanisms) {
    this.mechanisms = {};
    (mechanisms || [
      sasl_anon_default,
      sasl_external_default,
      sasl_oauthbearer_default,
      sasl_xoauth2_default,
      sasl_plain_default,
      sasl_sha1_default,
      sasl_sha256_default,
      sasl_sha384_default,
      sasl_sha512_default
    ]).forEach((m) => this.registerSASLMechanism(m));
  }
  /**
   * Register a single SASL mechanism, to be supported by this client.
   * @param {any} Mechanism - Object with a Strophe.SASLMechanism prototype
   */
  registerSASLMechanism(Mechanism) {
    const mechanism = new Mechanism();
    this.mechanisms[mechanism.mechname] = mechanism;
  }
  /**
   * Start the graceful disconnection process.
   *
   * This function starts the disconnection process.  This process starts
   * by sending unavailable presence and sending BOSH body of type
   * terminate.  A timeout handler makes sure that disconnection happens
   * even if the BOSH server does not respond.
   * If the Connection object isn't connected, at least tries to abort all pending requests
   * so the connection object won't generate successful requests (which were already opened).
   *
   * The user supplied connection callback will be notified of the
   * progress as this process happens.
   *
   * @param {string} [reason] - The reason the disconnect is occuring.
   */
  disconnect(reason) {
    this._changeConnectStatus(Status.DISCONNECTING, reason);
    if (reason) {
      log_default.info("Disconnect was called because: " + reason);
    } else {
      log_default.debug("Disconnect was called");
    }
    if (this.connected) {
      let pres = null;
      this.disconnecting = true;
      if (this.authenticated) {
        pres = $pres({
          "xmlns": NS.CLIENT,
          "type": "unavailable"
        });
      }
      this._disconnectTimeout = this._addSysTimedHandler(
        this.disconnection_timeout,
        this._onDisconnectTimeout.bind(this)
      );
      this._proto._disconnect(pres);
    } else {
      log_default.debug("Disconnect was called before Strophe connected to the server");
      this._proto._abortAllRequests();
      this._doDisconnect();
    }
  }
  /**
   * _Private_ helper function that makes sure plugins and the user's
   * callback are notified of connection status changes.
   * @param {number} status - the new connection status, one of the values
   *     in Strophe.Status
   * @param {string|null} [condition] - the error condition
   * @param {Element} [elem] - The triggering stanza.
   */
  _changeConnectStatus(status, condition, elem) {
    for (const k in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k)) {
        const plugin = this[k];
        if (plugin.statusChanged) {
          try {
            plugin.statusChanged(status, condition);
          } catch (err) {
            log_default.error(`${k} plugin caused an exception changing status: ${err}`);
          }
        }
      }
    }
    if (this.connect_callback) {
      try {
        this.connect_callback(status, condition, elem);
      } catch (e) {
        handleError(e);
        log_default.error(`User connection callback caused an exception: ${e}`);
      }
    }
  }
  /**
   * _Private_ function to disconnect.
   *
   * This is the last piece of the disconnection logic.  This resets the
   * connection and alerts the user's connection callback.
   * @param {string|null} [condition] - the error condition
   */
  _doDisconnect(condition) {
    if (typeof this._idleTimeout === "number") {
      clearTimeout(this._idleTimeout);
    }
    if (this._disconnectTimeout !== null) {
      this.deleteTimedHandler(this._disconnectTimeout);
      this._disconnectTimeout = null;
    }
    log_default.debug("_doDisconnect was called");
    this._proto._doDisconnect();
    this.authenticated = false;
    this.disconnecting = false;
    this.restored = false;
    this.handlers = [];
    this.timedHandlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this._changeConnectStatus(Status.DISCONNECTED, condition);
    this.connected = false;
  }
  /**
   * _Private_ handler to processes incoming data from the the connection.
   *
   * Except for _connect_cb handling the initial connection request,
   * this function handles the incoming data for all requests.  This
   * function also fires stanza handlers that match each incoming
   * stanza.
   * @param {Element | Request} req - The request that has data ready.
   * @param {string} [raw] - The stanza as raw string.
   */
  _dataRecv(req, raw) {
    const elem = (
      /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req
    );
    if (elem === null) {
      return;
    }
    if (this.xmlInput !== _Connection.prototype.xmlInput) {
      if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
        this.xmlInput(elem.childNodes[0]);
      } else {
        this.xmlInput(elem);
      }
    }
    if (this.rawInput !== _Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(builder_default.serialize(elem));
      }
    }
    while (this.removeHandlers.length > 0) {
      const hand = this.removeHandlers.pop();
      const i = this.handlers.indexOf(hand);
      if (i >= 0) {
        this.handlers.splice(i, 1);
      }
    }
    while (this.addHandlers.length > 0) {
      this.handlers.push(this.addHandlers.pop());
    }
    if (this.disconnecting && this._proto._emptyQueue()) {
      this._doDisconnect();
      return;
    }
    const type = elem.getAttribute("type");
    if (type !== null && type === "terminate") {
      if (this.disconnecting) {
        return;
      }
      let cond = elem.getAttribute("condition");
      const conflict = elem.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.UNKNOWN_REASON);
      }
      this._doDisconnect(cond);
      return;
    }
    forEachChild(
      elem,
      null,
      /** @param {Element} child */
      (child) => {
        const matches = [];
        this.handlers = this.handlers.reduce((handlers, handler) => {
          try {
            if (handler.isMatch(child) && (this.authenticated || !handler.user)) {
              if (handler.run(child)) {
                handlers.push(handler);
              }
              matches.push(handler);
            } else {
              handlers.push(handler);
            }
          } catch (e) {
            log_default.warn("Removing Strophe handlers due to uncaught exception: " + e.message);
          }
          return handlers;
        }, []);
        if (!matches.length && this.iqFallbackHandler.isMatch(child)) {
          this.iqFallbackHandler.run(child);
        }
      }
    );
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * _Private_ handler for initial connection request.
   *
   * This handler is used to process the initial connection request
   * response from the BOSH server. It is used to set up authentication
   * handlers and start the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {Element | Request} req - The current request.
   * @param {connectionCallback} _callback - low level (xmpp) connect callback function.
   *     Useful for plugins with their own xmpp connect callback (when they
   *     want to do something special).
   * @param {string} [raw] - The stanza as raw string.
   */
  _connect_cb(req, _callback, raw) {
    log_default.debug("_connect_cb was called");
    this.connected = true;
    let bodyWrap;
    try {
      bodyWrap = /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req;
    } catch (e) {
      if (e.name !== ErrorCondition.BAD_FORMAT) {
        throw e;
      }
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.BAD_FORMAT);
      this._doDisconnect(ErrorCondition.BAD_FORMAT);
    }
    if (!bodyWrap) {
      return;
    }
    if (this.xmlInput !== _Connection.prototype.xmlInput) {
      if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
        this.xmlInput(bodyWrap.childNodes[0]);
      } else {
        this.xmlInput(bodyWrap);
      }
    }
    if (this.rawInput !== _Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(builder_default.serialize(bodyWrap));
      }
    }
    const conncheck = this._proto._connect_cb(bodyWrap);
    if (conncheck === Status.CONNFAIL) {
      return;
    }
    let hasFeatures;
    if (bodyWrap.getElementsByTagNameNS) {
      hasFeatures = bodyWrap.getElementsByTagNameNS(NS.STREAM, "features").length > 0;
    } else {
      hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
    }
    if (!hasFeatures) {
      this._proto._no_auth_received(_callback);
      return;
    }
    const matched = Array.from(bodyWrap.getElementsByTagName("mechanism")).map((m) => this.mechanisms[m.textContent]).filter((m) => m);
    if (matched.length === 0) {
      if (bodyWrap.getElementsByTagName("auth").length === 0) {
        this._proto._no_auth_received(_callback);
        return;
      }
    }
    if (this.do_authentication !== false) {
      this.authenticate(matched);
    }
  }
  /**
   * Sorts an array of objects with prototype SASLMechanism according to
   * their priorities.
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   */
  // eslint-disable-next-line  class-methods-use-this
  sortMechanismsByPriority(mechanisms) {
    for (let i = 0; i < mechanisms.length - 1; ++i) {
      let higher = i;
      for (let j = i + 1; j < mechanisms.length; ++j) {
        if (mechanisms[j].priority > mechanisms[higher].priority) {
          higher = j;
        }
      }
      if (higher !== i) {
        const swap = mechanisms[i];
        mechanisms[i] = mechanisms[higher];
        mechanisms[higher] = swap;
      }
    }
    return mechanisms;
  }
  /**
   * Set up authentication
   *
   * Continues the initial connection request by setting up authentication
   * handlers and starting the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {SASLMechanism[]} matched - Array of SASL mechanisms supported.
   */
  authenticate(matched) {
    if (!this._attemptSASLAuth(matched)) {
      this._attemptLegacyAuth();
    }
  }
  /**
   * Iterate through an array of SASL mechanisms and attempt authentication
   * with the highest priority (enabled) mechanism.
   *
   * @private
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   * @return {Boolean} mechanism_found - true or false, depending on whether a
   *  valid SASL mechanism was found with which authentication could be started.
   */
  _attemptSASLAuth(mechanisms) {
    mechanisms = this.sortMechanismsByPriority(mechanisms || []);
    let mechanism_found = false;
    for (let i = 0; i < mechanisms.length; ++i) {
      if (!mechanisms[i].test(this)) {
        continue;
      }
      this._sasl_success_handler = this._addSysHandler(
        this._sasl_success_cb.bind(this),
        null,
        "success",
        null,
        null
      );
      this._sasl_failure_handler = this._addSysHandler(
        this._sasl_failure_cb.bind(this),
        null,
        "failure",
        null,
        null
      );
      this._sasl_challenge_handler = this._addSysHandler(
        this._sasl_challenge_cb.bind(this),
        null,
        "challenge",
        null,
        null
      );
      this._sasl_mechanism = mechanisms[i];
      this._sasl_mechanism.onStart(this);
      const request_auth_exchange = $build("auth", {
        "xmlns": NS.SASL,
        "mechanism": this._sasl_mechanism.mechname
      });
      if (this._sasl_mechanism.isClientFirst) {
        const response = this._sasl_mechanism.clientChallenge(this);
        request_auth_exchange.t((0, import_abab.btoa)(
          /** @type {string} */
          response
        ));
      }
      this.send(request_auth_exchange.tree());
      mechanism_found = true;
      break;
    }
    return mechanism_found;
  }
  /**
   * _Private_ handler for the SASL challenge
   * @private
   * @param {Element} elem
   */
  async _sasl_challenge_cb(elem) {
    const challenge = (0, import_abab.atob)(getText(elem));
    const response = await this._sasl_mechanism.onChallenge(this, challenge);
    const stanza = $build("response", { "xmlns": NS.SASL });
    if (response) stanza.t((0, import_abab.btoa)(response));
    this.send(stanza.tree());
    return true;
  }
  /**
   * Attempt legacy (i.e. non-SASL) authentication.
   * @private
   */
  _attemptLegacyAuth() {
    if (getNodeFromJid(this.jid) === null) {
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.MISSING_JID_NODE);
      this.disconnect(ErrorCondition.MISSING_JID_NODE);
    } else {
      this._changeConnectStatus(Status.AUTHENTICATING, null);
      this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1");
      this.send(
        $iq({
          "type": "get",
          "to": this.domain,
          "id": "_auth_1"
        }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).tree()
      );
    }
  }
  /**
   * _Private_ handler for legacy authentication.
   *
   * This handler is called in response to the initial <iq type='get'/>
   * for legacy authentication.  It builds an authentication <iq/> and
   * sends it, creating a handler (calling back to _auth2_cb()) to
   * handle the result
   * @private
   * @return {false} `false` to remove the handler.
   */
  // eslint-disable-next-line no-unused-vars
  //
  _onLegacyAuthIQResult() {
    const pass = typeof this.pass === "string" ? this.pass : "";
    const iq = $iq({ type: "set", id: "_auth_2" }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).up().c("password").t(pass);
    if (!getResourceFromJid(this.jid)) {
      this.jid = getBareJidFromJid(this.jid) + "/strophe";
    }
    iq.up().c("resource", {}).t(getResourceFromJid(this.jid));
    this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
    this.send(iq.tree());
    return false;
  }
  /**
   * _Private_ handler for succesful SASL authentication.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_success_cb(elem) {
    if (this._sasl_data["server-signature"]) {
      let serverSignature;
      const success = (0, import_abab.atob)(getText(elem));
      const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
      const matches = success.match(attribMatch);
      if (matches[1] === "v") {
        serverSignature = matches[2];
      }
      if (serverSignature !== this._sasl_data["server-signature"]) {
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
          this.deleteHandler(this._sasl_challenge_handler);
          this._sasl_challenge_handler = null;
        }
        this._sasl_data = {};
        return this._sasl_failure_cb(null);
      }
    }
    log_default.info("SASL authentication succeeded.");
    if (this._sasl_data.keys) {
      this.scram_keys = this._sasl_data.keys;
    }
    if (this._sasl_mechanism) {
      this._sasl_mechanism.onSuccess();
    }
    this.deleteHandler(this._sasl_failure_handler);
    this._sasl_failure_handler = null;
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    const streamfeature_handlers = [];
    const wrapper = (handlers, elem2) => {
      while (handlers.length) {
        this.deleteHandler(handlers.pop());
      }
      this._onStreamFeaturesAfterSASL(elem2);
      return false;
    };
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper(streamfeature_handlers, elem2),
        null,
        "stream:features",
        null,
        null
      )
    );
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper(streamfeature_handlers, elem2),
        NS.STREAM,
        "features",
        null,
        null
      )
    );
    this._sendRestart();
    return false;
  }
  /**
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onStreamFeaturesAfterSASL(elem) {
    this.features = elem;
    for (let i = 0; i < elem.childNodes.length; i++) {
      const child = elem.childNodes[i];
      if (child.nodeName === "bind") {
        this.do_bind = true;
      }
      if (child.nodeName === "session") {
        this.do_session = true;
      }
    }
    if (!this.do_bind) {
      this._changeConnectStatus(Status.AUTHFAIL, null);
      return false;
    } else if (!this.options.explicitResourceBinding) {
      this.bind();
    } else {
      this._changeConnectStatus(Status.BINDREQUIRED, null);
    }
    return false;
  }
  /**
   * Sends an IQ to the XMPP server to bind a JID resource for this session.
   *
   * https://tools.ietf.org/html/rfc6120#section-7.5
   *
   * If `explicitResourceBinding` was set to a truthy value in the options
   * passed to the Connection constructor, then this function needs
   * to be called explicitly by the client author.
   *
   * Otherwise it'll be called automatically as soon as the XMPP server
   * advertises the "urn:ietf:params:xml:ns:xmpp-bind" stream feature.
   */
  bind() {
    if (!this.do_bind) {
      log_default.info(`Connection.prototype.bind called but "do_bind" is false`);
      return;
    }
    this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
    const resource = getResourceFromJid(this.jid);
    if (resource) {
      this.send(
        $iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).c("resource", {}).t(resource).tree()
      );
    } else {
      this.send($iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).tree());
    }
  }
  /**
   * _Private_ handler for binding result and session start.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onResourceBindResultIQ(elem) {
    if (elem.getAttribute("type") === "error") {
      log_default.warn("Resource binding failed.");
      const conflict = elem.getElementsByTagName("conflict");
      let condition;
      if (conflict.length > 0) {
        condition = ErrorCondition.CONFLICT;
      }
      this._changeConnectStatus(Status.AUTHFAIL, condition, elem);
      return false;
    }
    const bind = elem.getElementsByTagName("bind");
    if (bind.length > 0) {
      const jidNode = bind[0].getElementsByTagName("jid");
      if (jidNode.length > 0) {
        this.authenticated = true;
        this.jid = getText(jidNode[0]);
        if (this.do_session) {
          this._establishSession();
        } else {
          this._changeConnectStatus(Status.CONNECTED, null);
        }
      }
    } else {
      log_default.warn("Resource binding failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
  }
  /**
   * Send IQ request to establish a session with the XMPP server.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   */
  _establishSession() {
    if (!this.do_session) {
      throw new Error(
        `Connection.prototype._establishSession called but apparently ${NS.SESSION} wasn't advertised by the server`
      );
    }
    this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2");
    this.send($iq({ type: "set", id: "_session_auth_2" }).c("session", { xmlns: NS.SESSION }).tree());
  }
  /**
   * _Private_ handler for the server's IQ response to a client's session
   * request.
   *
   * This sets Connection.authenticated to true on success, which
   * starts the processing of user handlers.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onSessionResultIQ(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this.authenticated = false;
      log_default.warn("Session creation failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
    return false;
  }
  /**
   * _Private_ handler for SASL authentication failure.
   * @param {Element} [elem] - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_failure_cb(elem) {
    if (this._sasl_success_handler) {
      this.deleteHandler(this._sasl_success_handler);
      this._sasl_success_handler = null;
    }
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    if (this._sasl_mechanism) this._sasl_mechanism.onFailure();
    this._changeConnectStatus(Status.AUTHFAIL, null, elem);
    return false;
  }
  /**
   * _Private_ handler to finish legacy authentication.
   *
   * This handler is called when the result from the jabber:iq:auth
   * <iq/> stanza is returned.
   * @private
   * @param {Element} elem - The stanza that triggered the callback.
   * @return {false} `false` to remove the handler.
   */
  _auth2_cb(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      this.disconnect("authentication failed");
    }
    return false;
  }
  /**
   * _Private_ function to add a system level timed handler.
   *
   * This function is used to add a TimedHandler for the
   * library code.  System timed handlers are allowed to run before
   * authentication is complete.
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   */
  _addSysTimedHandler(period, handler) {
    const thand = new timed_handler_default(period, handler);
    thand.user = false;
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * _Private_ function to add a system level stanza handler.
   *
   * This function is used to add a Handler for the
   * library code.  System stanza handlers are allowed to run before
   * authentication is complete.
   * @param {Function} handler - The callback function.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string} type - The stanza type attribute to match.
   * @param {string} id - The stanza id attribute to match.
   */
  _addSysHandler(handler, ns, name, type, id) {
    const hand = new handler_default(handler, ns, name, type, id);
    hand.user = false;
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * If the graceful disconnect process does not complete within the
   * time allotted, this handler finishes the disconnect anyway.
   * @return {false} `false` to remove the handler.
   */
  _onDisconnectTimeout() {
    log_default.debug("_onDisconnectTimeout was called");
    this._changeConnectStatus(Status.CONNTIMEOUT, null);
    this._proto._onDisconnectTimeout();
    this._doDisconnect();
    return false;
  }
  /**
   * _Private_ handler to process events during idle cycle.
   *
   * This handler is called every 100ms to fire timed handlers that
   * are ready and keep poll requests going.
   */
  _onIdle() {
    while (this.addTimeds.length > 0) {
      this.timedHandlers.push(this.addTimeds.pop());
    }
    while (this.removeTimeds.length > 0) {
      const thand = this.removeTimeds.pop();
      const i = this.timedHandlers.indexOf(thand);
      if (i >= 0) {
        this.timedHandlers.splice(i, 1);
      }
    }
    const now = (/* @__PURE__ */ new Date()).getTime();
    const newList = [];
    for (let i = 0; i < this.timedHandlers.length; i++) {
      const thand = this.timedHandlers[i];
      if (this.authenticated || !thand.user) {
        const since = thand.lastCalled + thand.period;
        if (since - now <= 0) {
          if (thand.run()) {
            newList.push(thand);
          }
        } else {
          newList.push(thand);
        }
      }
    }
    this.timedHandlers = newList;
    clearTimeout(this._idleTimeout);
    this._proto._onIdle();
    if (this.connected) {
      this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    }
  }
};
var connection_default = Connection;

// node_modules/strophe.js/src/stanza.js
var PARSE_ERROR_NS = "http://www.w3.org/1999/xhtml";
function toStanza(string, throwErrorIfInvalidNS) {
  const doc = xmlHtmlNode(string);
  if (doc.getElementsByTagNameNS(PARSE_ERROR_NS, "parsererror").length) {
    throw new Error(`Parser Error: ${string}`);
  }
  const node = doc.firstElementChild;
  if (["message", "iq", "presence"].includes(node.nodeName.toLowerCase()) && node.namespaceURI !== "jabber:client" && node.namespaceURI !== "jabber:server") {
    const err_msg = `Invalid namespaceURI ${node.namespaceURI}`;
    if (throwErrorIfInvalidNS) {
      throw new Error(err_msg);
    } else {
      log_default.error(err_msg);
    }
  }
  return node;
}
var Stanza = class {
  /**
   * @param { string[] } strings
   * @param { any[] } values
   */
  constructor(strings, values) {
    this.strings = strings;
    this.values = values;
  }
  /**
   * @return { string }
   */
  toString() {
    this.string = this.string || this.strings.reduce((acc, str) => {
      const idx = this.strings.indexOf(str);
      const value = this.values.length > idx ? this.values[idx].toString() : "";
      return acc + str + value;
    }, "");
    return this.string;
  }
  /**
   * @return { Element }
   */
  tree() {
    this.node = this.node ?? toStanza(this.toString(), true);
    return this.node;
  }
};
function stx(strings, ...values) {
  return new Stanza(strings, values);
}

// node_modules/strophe.js/src/index.js
var Strophe = {
  /** @constant: VERSION */
  VERSION: "3.0.0",
  /**
   * @returns {number}
   */
  get TIMEOUT() {
    return bosh_default.getTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set TIMEOUT(n) {
    bosh_default.setTimeoutMultiplier(n);
  },
  /**
   * @returns {number}
   */
  get SECONDARY_TIMEOUT() {
    return bosh_default.getSecondaryTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set SECONDARY_TIMEOUT(n) {
    bosh_default.setSecondaryTimeoutMultiplier(n);
  },
  ...utils_exports,
  ...log_default,
  shims: shims_exports,
  Request: request_default,
  // Transports
  Bosh: bosh_default,
  Websocket: websocket_default,
  WorkerWebsocket: worker_websocket_default,
  Connection: connection_default,
  Handler: handler_default,
  // Available authentication mechanisms
  SASLAnonymous: sasl_anon_default,
  SASLPlain: sasl_plain_default,
  SASLSHA1: sasl_sha1_default,
  SASLSHA256: sasl_sha256_default,
  SASLSHA384: sasl_sha384_default,
  SASLSHA512: sasl_sha512_default,
  SASLOAuthBearer: sasl_oauthbearer_default,
  SASLExternal: sasl_external_default,
  SASLXOAuth2: sasl_xoauth2_default,
  Builder: builder_default,
  ElementType,
  ErrorCondition,
  LogLevel: LOG_LEVELS,
  /** @type {Object.<string, string>} */
  NS,
  SASLMechanism: sasl_default,
  /** @type {Status} */
  Status,
  TimedHandler: timed_handler_default,
  XHTML: {
    ...XHTML,
    validTag,
    validCSS,
    validAttribute
  },
  /**
   * Render a DOM element and all descendants to a String.
   * @method Strophe.serialize
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  serialize(elem) {
    return builder_default.serialize(elem);
  },
  /**
   * @typedef {import('./constants').LogLevel} LogLevel
   *
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    log_default.setLogLevel(level);
  },
  /**
   * This function is used to extend the current namespaces in
   * Strophe.NS. It takes a key and a value with the key being the
   * name of the new namespace, with its actual value.
   * @example: Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
   *
   * @param {string} name - The name under which the namespace will be
   *     referenced under Strophe.NS
   * @param {string} value - The actual namespace.
   */
  addNamespace(name, value) {
    Strophe.NS[name] = value;
  },
  /**
   * Extends the Strophe.Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  addConnectionPlugin(name, ptype) {
    connection_default.addConnectionPlugin(name, ptype);
  }
};
globalThis.$build = $build;
globalThis.$iq = $iq;
globalThis.$msg = $msg;
globalThis.$pres = $pres;
globalThis.Strophe = Strophe;
export {
  $build,
  $iq,
  $msg,
  $pres,
  builder_default as Builder,
  request_default as Request,
  Stanza,
  Strophe,
  stx,
  toStanza
};
/*! Bundled license information:

strophe.js/src/worker-websocket.js:
  (**
   * @license MIT
   * @copyright JC Brand
   *)
*/
//# sourceMappingURL=strophe__js.js.map
