var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "",
      aacute: "",
      Abreve: "",
      abreve: "",
      ac: "",
      acd: "",
      acE: "",
      Acirc: "",
      acirc: "",
      acute: "",
      Acy: "",
      acy: "",
      AElig: "",
      aelig: "",
      af: "",
      Afr: "",
      afr: "",
      Agrave: "",
      agrave: "",
      alefsym: "",
      aleph: "",
      Alpha: "",
      alpha: "",
      Amacr: "",
      amacr: "",
      amalg: "",
      AMP: "&",
      amp: "&",
      And: "",
      and: "",
      andand: "",
      andd: "",
      andslope: "",
      andv: "",
      ang: "",
      ange: "",
      angle: "",
      angmsd: "",
      angmsdaa: "",
      angmsdab: "",
      angmsdac: "",
      angmsdad: "",
      angmsdae: "",
      angmsdaf: "",
      angmsdag: "",
      angmsdah: "",
      angrt: "",
      angrtvb: "",
      angrtvbd: "",
      angsph: "",
      angst: "",
      angzarr: "",
      Aogon: "",
      aogon: "",
      Aopf: "",
      aopf: "",
      ap: "",
      apacir: "",
      apE: "",
      ape: "",
      apid: "",
      apos: "'",
      ApplyFunction: "",
      approx: "",
      approxeq: "",
      Aring: "",
      aring: "",
      Ascr: "",
      ascr: "",
      Assign: "",
      ast: "*",
      asymp: "",
      asympeq: "",
      Atilde: "",
      atilde: "",
      Auml: "",
      auml: "",
      awconint: "",
      awint: "",
      backcong: "",
      backepsilon: "",
      backprime: "",
      backsim: "",
      backsimeq: "",
      Backslash: "",
      Barv: "",
      barvee: "",
      Barwed: "",
      barwed: "",
      barwedge: "",
      bbrk: "",
      bbrktbrk: "",
      bcong: "",
      Bcy: "",
      bcy: "",
      bdquo: "",
      becaus: "",
      Because: "",
      because: "",
      bemptyv: "",
      bepsi: "",
      bernou: "",
      Bernoullis: "",
      Beta: "",
      beta: "",
      beth: "",
      between: "",
      Bfr: "",
      bfr: "",
      bigcap: "",
      bigcirc: "",
      bigcup: "",
      bigodot: "",
      bigoplus: "",
      bigotimes: "",
      bigsqcup: "",
      bigstar: "",
      bigtriangledown: "",
      bigtriangleup: "",
      biguplus: "",
      bigvee: "",
      bigwedge: "",
      bkarow: "",
      blacklozenge: "",
      blacksquare: "",
      blacktriangle: "",
      blacktriangledown: "",
      blacktriangleleft: "",
      blacktriangleright: "",
      blank: "",
      blk12: "",
      blk14: "",
      blk34: "",
      block: "",
      bne: "=",
      bnequiv: "",
      bNot: "",
      bnot: "",
      Bopf: "",
      bopf: "",
      bot: "",
      bottom: "",
      bowtie: "",
      boxbox: "",
      boxDL: "",
      boxDl: "",
      boxdL: "",
      boxdl: "",
      boxDR: "",
      boxDr: "",
      boxdR: "",
      boxdr: "",
      boxH: "",
      boxh: "",
      boxHD: "",
      boxHd: "",
      boxhD: "",
      boxhd: "",
      boxHU: "",
      boxHu: "",
      boxhU: "",
      boxhu: "",
      boxminus: "",
      boxplus: "",
      boxtimes: "",
      boxUL: "",
      boxUl: "",
      boxuL: "",
      boxul: "",
      boxUR: "",
      boxUr: "",
      boxuR: "",
      boxur: "",
      boxV: "",
      boxv: "",
      boxVH: "",
      boxVh: "",
      boxvH: "",
      boxvh: "",
      boxVL: "",
      boxVl: "",
      boxvL: "",
      boxvl: "",
      boxVR: "",
      boxVr: "",
      boxvR: "",
      boxvr: "",
      bprime: "",
      Breve: "",
      breve: "",
      brvbar: "",
      Bscr: "",
      bscr: "",
      bsemi: "",
      bsim: "",
      bsime: "",
      bsol: "\\",
      bsolb: "",
      bsolhsub: "",
      bull: "",
      bullet: "",
      bump: "",
      bumpE: "",
      bumpe: "",
      Bumpeq: "",
      bumpeq: "",
      Cacute: "",
      cacute: "",
      Cap: "",
      cap: "",
      capand: "",
      capbrcup: "",
      capcap: "",
      capcup: "",
      capdot: "",
      CapitalDifferentialD: "",
      caps: "",
      caret: "",
      caron: "",
      Cayleys: "",
      ccaps: "",
      Ccaron: "",
      ccaron: "",
      Ccedil: "",
      ccedil: "",
      Ccirc: "",
      ccirc: "",
      Cconint: "",
      ccups: "",
      ccupssm: "",
      Cdot: "",
      cdot: "",
      cedil: "",
      Cedilla: "",
      cemptyv: "",
      cent: "",
      CenterDot: "",
      centerdot: "",
      Cfr: "",
      cfr: "",
      CHcy: "",
      chcy: "",
      check: "",
      checkmark: "",
      Chi: "",
      chi: "",
      cir: "",
      circ: "",
      circeq: "",
      circlearrowleft: "",
      circlearrowright: "",
      circledast: "",
      circledcirc: "",
      circleddash: "",
      CircleDot: "",
      circledR: "",
      circledS: "",
      CircleMinus: "",
      CirclePlus: "",
      CircleTimes: "",
      cirE: "",
      cire: "",
      cirfnint: "",
      cirmid: "",
      cirscir: "",
      ClockwiseContourIntegral: "",
      CloseCurlyDoubleQuote: "",
      CloseCurlyQuote: "",
      clubs: "",
      clubsuit: "",
      Colon: "",
      colon: ":",
      Colone: "",
      colone: "",
      coloneq: "",
      comma: ",",
      commat: "@",
      comp: "",
      compfn: "",
      complement: "",
      complexes: "",
      cong: "",
      congdot: "",
      Congruent: "",
      Conint: "",
      conint: "",
      ContourIntegral: "",
      Copf: "",
      copf: "",
      coprod: "",
      Coproduct: "",
      COPY: "",
      copy: "",
      copysr: "",
      CounterClockwiseContourIntegral: "",
      crarr: "",
      Cross: "",
      cross: "",
      Cscr: "",
      cscr: "",
      csub: "",
      csube: "",
      csup: "",
      csupe: "",
      ctdot: "",
      cudarrl: "",
      cudarrr: "",
      cuepr: "",
      cuesc: "",
      cularr: "",
      cularrp: "",
      Cup: "",
      cup: "",
      cupbrcap: "",
      CupCap: "",
      cupcap: "",
      cupcup: "",
      cupdot: "",
      cupor: "",
      cups: "",
      curarr: "",
      curarrm: "",
      curlyeqprec: "",
      curlyeqsucc: "",
      curlyvee: "",
      curlywedge: "",
      curren: "",
      curvearrowleft: "",
      curvearrowright: "",
      cuvee: "",
      cuwed: "",
      cwconint: "",
      cwint: "",
      cylcty: "",
      Dagger: "",
      dagger: "",
      daleth: "",
      Darr: "",
      dArr: "",
      darr: "",
      dash: "",
      Dashv: "",
      dashv: "",
      dbkarow: "",
      dblac: "",
      Dcaron: "",
      dcaron: "",
      Dcy: "",
      dcy: "",
      DD: "",
      dd: "",
      ddagger: "",
      ddarr: "",
      DDotrahd: "",
      ddotseq: "",
      deg: "",
      Del: "",
      Delta: "",
      delta: "",
      demptyv: "",
      dfisht: "",
      Dfr: "",
      dfr: "",
      dHar: "",
      dharl: "",
      dharr: "",
      DiacriticalAcute: "",
      DiacriticalDot: "",
      DiacriticalDoubleAcute: "",
      DiacriticalGrave: "`",
      DiacriticalTilde: "",
      diam: "",
      Diamond: "",
      diamond: "",
      diamondsuit: "",
      diams: "",
      die: "",
      DifferentialD: "",
      digamma: "",
      disin: "",
      div: "",
      divide: "",
      divideontimes: "",
      divonx: "",
      DJcy: "",
      djcy: "",
      dlcorn: "",
      dlcrop: "",
      dollar: "$",
      Dopf: "",
      dopf: "",
      Dot: "",
      dot: "",
      DotDot: "",
      doteq: "",
      doteqdot: "",
      DotEqual: "",
      dotminus: "",
      dotplus: "",
      dotsquare: "",
      doublebarwedge: "",
      DoubleContourIntegral: "",
      DoubleDot: "",
      DoubleDownArrow: "",
      DoubleLeftArrow: "",
      DoubleLeftRightArrow: "",
      DoubleLeftTee: "",
      DoubleLongLeftArrow: "",
      DoubleLongLeftRightArrow: "",
      DoubleLongRightArrow: "",
      DoubleRightArrow: "",
      DoubleRightTee: "",
      DoubleUpArrow: "",
      DoubleUpDownArrow: "",
      DoubleVerticalBar: "",
      DownArrow: "",
      Downarrow: "",
      downarrow: "",
      DownArrowBar: "",
      DownArrowUpArrow: "",
      DownBreve: "",
      downdownarrows: "",
      downharpoonleft: "",
      downharpoonright: "",
      DownLeftRightVector: "",
      DownLeftTeeVector: "",
      DownLeftVector: "",
      DownLeftVectorBar: "",
      DownRightTeeVector: "",
      DownRightVector: "",
      DownRightVectorBar: "",
      DownTee: "",
      DownTeeArrow: "",
      drbkarow: "",
      drcorn: "",
      drcrop: "",
      Dscr: "",
      dscr: "",
      DScy: "",
      dscy: "",
      dsol: "",
      Dstrok: "",
      dstrok: "",
      dtdot: "",
      dtri: "",
      dtrif: "",
      duarr: "",
      duhar: "",
      dwangle: "",
      DZcy: "",
      dzcy: "",
      dzigrarr: "",
      Eacute: "",
      eacute: "",
      easter: "",
      Ecaron: "",
      ecaron: "",
      ecir: "",
      Ecirc: "",
      ecirc: "",
      ecolon: "",
      Ecy: "",
      ecy: "",
      eDDot: "",
      Edot: "",
      eDot: "",
      edot: "",
      ee: "",
      efDot: "",
      Efr: "",
      efr: "",
      eg: "",
      Egrave: "",
      egrave: "",
      egs: "",
      egsdot: "",
      el: "",
      Element: "",
      elinters: "",
      ell: "",
      els: "",
      elsdot: "",
      Emacr: "",
      emacr: "",
      empty: "",
      emptyset: "",
      EmptySmallSquare: "",
      emptyv: "",
      EmptyVerySmallSquare: "",
      emsp: "",
      emsp13: "",
      emsp14: "",
      ENG: "",
      eng: "",
      ensp: "",
      Eogon: "",
      eogon: "",
      Eopf: "",
      eopf: "",
      epar: "",
      eparsl: "",
      eplus: "",
      epsi: "",
      Epsilon: "",
      epsilon: "",
      epsiv: "",
      eqcirc: "",
      eqcolon: "",
      eqsim: "",
      eqslantgtr: "",
      eqslantless: "",
      Equal: "",
      equals: "=",
      EqualTilde: "",
      equest: "",
      Equilibrium: "",
      equiv: "",
      equivDD: "",
      eqvparsl: "",
      erarr: "",
      erDot: "",
      Escr: "",
      escr: "",
      esdot: "",
      Esim: "",
      esim: "",
      Eta: "",
      eta: "",
      ETH: "",
      eth: "",
      Euml: "",
      euml: "",
      euro: "",
      excl: "!",
      exist: "",
      Exists: "",
      expectation: "",
      ExponentialE: "",
      exponentiale: "",
      fallingdotseq: "",
      Fcy: "",
      fcy: "",
      female: "",
      ffilig: "",
      fflig: "",
      ffllig: "",
      Ffr: "",
      ffr: "",
      filig: "",
      FilledSmallSquare: "",
      FilledVerySmallSquare: "",
      fjlig: "fj",
      flat: "",
      fllig: "",
      fltns: "",
      fnof: "",
      Fopf: "",
      fopf: "",
      ForAll: "",
      forall: "",
      fork: "",
      forkv: "",
      Fouriertrf: "",
      fpartint: "",
      frac12: "",
      frac13: "",
      frac14: "",
      frac15: "",
      frac16: "",
      frac18: "",
      frac23: "",
      frac25: "",
      frac34: "",
      frac35: "",
      frac38: "",
      frac45: "",
      frac56: "",
      frac58: "",
      frac78: "",
      frasl: "",
      frown: "",
      Fscr: "",
      fscr: "",
      gacute: "",
      Gamma: "",
      gamma: "",
      Gammad: "",
      gammad: "",
      gap: "",
      Gbreve: "",
      gbreve: "",
      Gcedil: "",
      Gcirc: "",
      gcirc: "",
      Gcy: "",
      gcy: "",
      Gdot: "",
      gdot: "",
      gE: "",
      ge: "",
      gEl: "",
      gel: "",
      geq: "",
      geqq: "",
      geqslant: "",
      ges: "",
      gescc: "",
      gesdot: "",
      gesdoto: "",
      gesdotol: "",
      gesl: "",
      gesles: "",
      Gfr: "",
      gfr: "",
      Gg: "",
      gg: "",
      ggg: "",
      gimel: "",
      GJcy: "",
      gjcy: "",
      gl: "",
      gla: "",
      glE: "",
      glj: "",
      gnap: "",
      gnapprox: "",
      gnE: "",
      gne: "",
      gneq: "",
      gneqq: "",
      gnsim: "",
      Gopf: "",
      gopf: "",
      grave: "`",
      GreaterEqual: "",
      GreaterEqualLess: "",
      GreaterFullEqual: "",
      GreaterGreater: "",
      GreaterLess: "",
      GreaterSlantEqual: "",
      GreaterTilde: "",
      Gscr: "",
      gscr: "",
      gsim: "",
      gsime: "",
      gsiml: "",
      Gt: "",
      GT: ">",
      gt: ">",
      gtcc: "",
      gtcir: "",
      gtdot: "",
      gtlPar: "",
      gtquest: "",
      gtrapprox: "",
      gtrarr: "",
      gtrdot: "",
      gtreqless: "",
      gtreqqless: "",
      gtrless: "",
      gtrsim: "",
      gvertneqq: "",
      gvnE: "",
      Hacek: "",
      hairsp: "",
      half: "",
      hamilt: "",
      HARDcy: "",
      hardcy: "",
      hArr: "",
      harr: "",
      harrcir: "",
      harrw: "",
      Hat: "^",
      hbar: "",
      Hcirc: "",
      hcirc: "",
      hearts: "",
      heartsuit: "",
      hellip: "",
      hercon: "",
      Hfr: "",
      hfr: "",
      HilbertSpace: "",
      hksearow: "",
      hkswarow: "",
      hoarr: "",
      homtht: "",
      hookleftarrow: "",
      hookrightarrow: "",
      Hopf: "",
      hopf: "",
      horbar: "",
      HorizontalLine: "",
      Hscr: "",
      hscr: "",
      hslash: "",
      Hstrok: "",
      hstrok: "",
      HumpDownHump: "",
      HumpEqual: "",
      hybull: "",
      hyphen: "",
      Iacute: "",
      iacute: "",
      ic: "",
      Icirc: "",
      icirc: "",
      Icy: "",
      icy: "",
      Idot: "",
      IEcy: "",
      iecy: "",
      iexcl: "",
      iff: "",
      Ifr: "",
      ifr: "",
      Igrave: "",
      igrave: "",
      ii: "",
      iiiint: "",
      iiint: "",
      iinfin: "",
      iiota: "",
      IJlig: "",
      ijlig: "",
      Im: "",
      Imacr: "",
      imacr: "",
      image: "",
      ImaginaryI: "",
      imagline: "",
      imagpart: "",
      imath: "",
      imof: "",
      imped: "",
      Implies: "",
      in: "",
      incare: "",
      infin: "",
      infintie: "",
      inodot: "",
      Int: "",
      int: "",
      intcal: "",
      integers: "",
      Integral: "",
      intercal: "",
      Intersection: "",
      intlarhk: "",
      intprod: "",
      InvisibleComma: "",
      InvisibleTimes: "",
      IOcy: "",
      iocy: "",
      Iogon: "",
      iogon: "",
      Iopf: "",
      iopf: "",
      Iota: "",
      iota: "",
      iprod: "",
      iquest: "",
      Iscr: "",
      iscr: "",
      isin: "",
      isindot: "",
      isinE: "",
      isins: "",
      isinsv: "",
      isinv: "",
      it: "",
      Itilde: "",
      itilde: "",
      Iukcy: "",
      iukcy: "",
      Iuml: "",
      iuml: "",
      Jcirc: "",
      jcirc: "",
      Jcy: "",
      jcy: "",
      Jfr: "",
      jfr: "",
      jmath: "",
      Jopf: "",
      jopf: "",
      Jscr: "",
      jscr: "",
      Jsercy: "",
      jsercy: "",
      Jukcy: "",
      jukcy: "",
      Kappa: "",
      kappa: "",
      kappav: "",
      Kcedil: "",
      kcedil: "",
      Kcy: "",
      kcy: "",
      Kfr: "",
      kfr: "",
      kgreen: "",
      KHcy: "",
      khcy: "",
      KJcy: "",
      kjcy: "",
      Kopf: "",
      kopf: "",
      Kscr: "",
      kscr: "",
      lAarr: "",
      Lacute: "",
      lacute: "",
      laemptyv: "",
      lagran: "",
      Lambda: "",
      lambda: "",
      Lang: "",
      lang: "",
      langd: "",
      langle: "",
      lap: "",
      Laplacetrf: "",
      laquo: "",
      Larr: "",
      lArr: "",
      larr: "",
      larrb: "",
      larrbfs: "",
      larrfs: "",
      larrhk: "",
      larrlp: "",
      larrpl: "",
      larrsim: "",
      larrtl: "",
      lat: "",
      lAtail: "",
      latail: "",
      late: "",
      lates: "",
      lBarr: "",
      lbarr: "",
      lbbrk: "",
      lbrace: "{",
      lbrack: "[",
      lbrke: "",
      lbrksld: "",
      lbrkslu: "",
      Lcaron: "",
      lcaron: "",
      Lcedil: "",
      lcedil: "",
      lceil: "",
      lcub: "{",
      Lcy: "",
      lcy: "",
      ldca: "",
      ldquo: "",
      ldquor: "",
      ldrdhar: "",
      ldrushar: "",
      ldsh: "",
      lE: "",
      le: "",
      LeftAngleBracket: "",
      LeftArrow: "",
      Leftarrow: "",
      leftarrow: "",
      LeftArrowBar: "",
      LeftArrowRightArrow: "",
      leftarrowtail: "",
      LeftCeiling: "",
      LeftDoubleBracket: "",
      LeftDownTeeVector: "",
      LeftDownVector: "",
      LeftDownVectorBar: "",
      LeftFloor: "",
      leftharpoondown: "",
      leftharpoonup: "",
      leftleftarrows: "",
      LeftRightArrow: "",
      Leftrightarrow: "",
      leftrightarrow: "",
      leftrightarrows: "",
      leftrightharpoons: "",
      leftrightsquigarrow: "",
      LeftRightVector: "",
      LeftTee: "",
      LeftTeeArrow: "",
      LeftTeeVector: "",
      leftthreetimes: "",
      LeftTriangle: "",
      LeftTriangleBar: "",
      LeftTriangleEqual: "",
      LeftUpDownVector: "",
      LeftUpTeeVector: "",
      LeftUpVector: "",
      LeftUpVectorBar: "",
      LeftVector: "",
      LeftVectorBar: "",
      lEg: "",
      leg: "",
      leq: "",
      leqq: "",
      leqslant: "",
      les: "",
      lescc: "",
      lesdot: "",
      lesdoto: "",
      lesdotor: "",
      lesg: "",
      lesges: "",
      lessapprox: "",
      lessdot: "",
      lesseqgtr: "",
      lesseqqgtr: "",
      LessEqualGreater: "",
      LessFullEqual: "",
      LessGreater: "",
      lessgtr: "",
      LessLess: "",
      lesssim: "",
      LessSlantEqual: "",
      LessTilde: "",
      lfisht: "",
      lfloor: "",
      Lfr: "",
      lfr: "",
      lg: "",
      lgE: "",
      lHar: "",
      lhard: "",
      lharu: "",
      lharul: "",
      lhblk: "",
      LJcy: "",
      ljcy: "",
      Ll: "",
      ll: "",
      llarr: "",
      llcorner: "",
      Lleftarrow: "",
      llhard: "",
      lltri: "",
      Lmidot: "",
      lmidot: "",
      lmoust: "",
      lmoustache: "",
      lnap: "",
      lnapprox: "",
      lnE: "",
      lne: "",
      lneq: "",
      lneqq: "",
      lnsim: "",
      loang: "",
      loarr: "",
      lobrk: "",
      LongLeftArrow: "",
      Longleftarrow: "",
      longleftarrow: "",
      LongLeftRightArrow: "",
      Longleftrightarrow: "",
      longleftrightarrow: "",
      longmapsto: "",
      LongRightArrow: "",
      Longrightarrow: "",
      longrightarrow: "",
      looparrowleft: "",
      looparrowright: "",
      lopar: "",
      Lopf: "",
      lopf: "",
      loplus: "",
      lotimes: "",
      lowast: "",
      lowbar: "_",
      LowerLeftArrow: "",
      LowerRightArrow: "",
      loz: "",
      lozenge: "",
      lozf: "",
      lpar: "(",
      lparlt: "",
      lrarr: "",
      lrcorner: "",
      lrhar: "",
      lrhard: "",
      lrm: "",
      lrtri: "",
      lsaquo: "",
      Lscr: "",
      lscr: "",
      Lsh: "",
      lsh: "",
      lsim: "",
      lsime: "",
      lsimg: "",
      lsqb: "[",
      lsquo: "",
      lsquor: "",
      Lstrok: "",
      lstrok: "",
      Lt: "",
      LT: "<",
      lt: "<",
      ltcc: "",
      ltcir: "",
      ltdot: "",
      lthree: "",
      ltimes: "",
      ltlarr: "",
      ltquest: "",
      ltri: "",
      ltrie: "",
      ltrif: "",
      ltrPar: "",
      lurdshar: "",
      luruhar: "",
      lvertneqq: "",
      lvnE: "",
      macr: "",
      male: "",
      malt: "",
      maltese: "",
      Map: "",
      map: "",
      mapsto: "",
      mapstodown: "",
      mapstoleft: "",
      mapstoup: "",
      marker: "",
      mcomma: "",
      Mcy: "",
      mcy: "",
      mdash: "",
      mDDot: "",
      measuredangle: "",
      MediumSpace: "",
      Mellintrf: "",
      Mfr: "",
      mfr: "",
      mho: "",
      micro: "",
      mid: "",
      midast: "*",
      midcir: "",
      middot: "",
      minus: "",
      minusb: "",
      minusd: "",
      minusdu: "",
      MinusPlus: "",
      mlcp: "",
      mldr: "",
      mnplus: "",
      models: "",
      Mopf: "",
      mopf: "",
      mp: "",
      Mscr: "",
      mscr: "",
      mstpos: "",
      Mu: "",
      mu: "",
      multimap: "",
      mumap: "",
      nabla: "",
      Nacute: "",
      nacute: "",
      nang: "",
      nap: "",
      napE: "",
      napid: "",
      napos: "",
      napprox: "",
      natur: "",
      natural: "",
      naturals: "",
      nbsp: "",
      nbump: "",
      nbumpe: "",
      ncap: "",
      Ncaron: "",
      ncaron: "",
      Ncedil: "",
      ncedil: "",
      ncong: "",
      ncongdot: "",
      ncup: "",
      Ncy: "",
      ncy: "",
      ndash: "",
      ne: "",
      nearhk: "",
      neArr: "",
      nearr: "",
      nearrow: "",
      nedot: "",
      NegativeMediumSpace: "",
      NegativeThickSpace: "",
      NegativeThinSpace: "",
      NegativeVeryThinSpace: "",
      nequiv: "",
      nesear: "",
      nesim: "",
      NestedGreaterGreater: "",
      NestedLessLess: "",
      NewLine: "\n",
      nexist: "",
      nexists: "",
      Nfr: "",
      nfr: "",
      ngE: "",
      nge: "",
      ngeq: "",
      ngeqq: "",
      ngeqslant: "",
      nges: "",
      nGg: "",
      ngsim: "",
      nGt: "",
      ngt: "",
      ngtr: "",
      nGtv: "",
      nhArr: "",
      nharr: "",
      nhpar: "",
      ni: "",
      nis: "",
      nisd: "",
      niv: "",
      NJcy: "",
      njcy: "",
      nlArr: "",
      nlarr: "",
      nldr: "",
      nlE: "",
      nle: "",
      nLeftarrow: "",
      nleftarrow: "",
      nLeftrightarrow: "",
      nleftrightarrow: "",
      nleq: "",
      nleqq: "",
      nleqslant: "",
      nles: "",
      nless: "",
      nLl: "",
      nlsim: "",
      nLt: "",
      nlt: "",
      nltri: "",
      nltrie: "",
      nLtv: "",
      nmid: "",
      NoBreak: "",
      NonBreakingSpace: "",
      Nopf: "",
      nopf: "",
      Not: "",
      not: "",
      NotCongruent: "",
      NotCupCap: "",
      NotDoubleVerticalBar: "",
      NotElement: "",
      NotEqual: "",
      NotEqualTilde: "",
      NotExists: "",
      NotGreater: "",
      NotGreaterEqual: "",
      NotGreaterFullEqual: "",
      NotGreaterGreater: "",
      NotGreaterLess: "",
      NotGreaterSlantEqual: "",
      NotGreaterTilde: "",
      NotHumpDownHump: "",
      NotHumpEqual: "",
      notin: "",
      notindot: "",
      notinE: "",
      notinva: "",
      notinvb: "",
      notinvc: "",
      NotLeftTriangle: "",
      NotLeftTriangleBar: "",
      NotLeftTriangleEqual: "",
      NotLess: "",
      NotLessEqual: "",
      NotLessGreater: "",
      NotLessLess: "",
      NotLessSlantEqual: "",
      NotLessTilde: "",
      NotNestedGreaterGreater: "",
      NotNestedLessLess: "",
      notni: "",
      notniva: "",
      notnivb: "",
      notnivc: "",
      NotPrecedes: "",
      NotPrecedesEqual: "",
      NotPrecedesSlantEqual: "",
      NotReverseElement: "",
      NotRightTriangle: "",
      NotRightTriangleBar: "",
      NotRightTriangleEqual: "",
      NotSquareSubset: "",
      NotSquareSubsetEqual: "",
      NotSquareSuperset: "",
      NotSquareSupersetEqual: "",
      NotSubset: "",
      NotSubsetEqual: "",
      NotSucceeds: "",
      NotSucceedsEqual: "",
      NotSucceedsSlantEqual: "",
      NotSucceedsTilde: "",
      NotSuperset: "",
      NotSupersetEqual: "",
      NotTilde: "",
      NotTildeEqual: "",
      NotTildeFullEqual: "",
      NotTildeTilde: "",
      NotVerticalBar: "",
      npar: "",
      nparallel: "",
      nparsl: "",
      npart: "",
      npolint: "",
      npr: "",
      nprcue: "",
      npre: "",
      nprec: "",
      npreceq: "",
      nrArr: "",
      nrarr: "",
      nrarrc: "",
      nrarrw: "",
      nRightarrow: "",
      nrightarrow: "",
      nrtri: "",
      nrtrie: "",
      nsc: "",
      nsccue: "",
      nsce: "",
      Nscr: "",
      nscr: "",
      nshortmid: "",
      nshortparallel: "",
      nsim: "",
      nsime: "",
      nsimeq: "",
      nsmid: "",
      nspar: "",
      nsqsube: "",
      nsqsupe: "",
      nsub: "",
      nsubE: "",
      nsube: "",
      nsubset: "",
      nsubseteq: "",
      nsubseteqq: "",
      nsucc: "",
      nsucceq: "",
      nsup: "",
      nsupE: "",
      nsupe: "",
      nsupset: "",
      nsupseteq: "",
      nsupseteqq: "",
      ntgl: "",
      Ntilde: "",
      ntilde: "",
      ntlg: "",
      ntriangleleft: "",
      ntrianglelefteq: "",
      ntriangleright: "",
      ntrianglerighteq: "",
      Nu: "",
      nu: "",
      num: "#",
      numero: "",
      numsp: "",
      nvap: "",
      nVDash: "",
      nVdash: "",
      nvDash: "",
      nvdash: "",
      nvge: "",
      nvgt: ">",
      nvHarr: "",
      nvinfin: "",
      nvlArr: "",
      nvle: "",
      nvlt: "<",
      nvltrie: "",
      nvrArr: "",
      nvrtrie: "",
      nvsim: "",
      nwarhk: "",
      nwArr: "",
      nwarr: "",
      nwarrow: "",
      nwnear: "",
      Oacute: "",
      oacute: "",
      oast: "",
      ocir: "",
      Ocirc: "",
      ocirc: "",
      Ocy: "",
      ocy: "",
      odash: "",
      Odblac: "",
      odblac: "",
      odiv: "",
      odot: "",
      odsold: "",
      OElig: "",
      oelig: "",
      ofcir: "",
      Ofr: "",
      ofr: "",
      ogon: "",
      Ograve: "",
      ograve: "",
      ogt: "",
      ohbar: "",
      ohm: "",
      oint: "",
      olarr: "",
      olcir: "",
      olcross: "",
      oline: "",
      olt: "",
      Omacr: "",
      omacr: "",
      Omega: "",
      omega: "",
      Omicron: "",
      omicron: "",
      omid: "",
      ominus: "",
      Oopf: "",
      oopf: "",
      opar: "",
      OpenCurlyDoubleQuote: "",
      OpenCurlyQuote: "",
      operp: "",
      oplus: "",
      Or: "",
      or: "",
      orarr: "",
      ord: "",
      order: "",
      orderof: "",
      ordf: "",
      ordm: "",
      origof: "",
      oror: "",
      orslope: "",
      orv: "",
      oS: "",
      Oscr: "",
      oscr: "",
      Oslash: "",
      oslash: "",
      osol: "",
      Otilde: "",
      otilde: "",
      Otimes: "",
      otimes: "",
      otimesas: "",
      Ouml: "",
      ouml: "",
      ovbar: "",
      OverBar: "",
      OverBrace: "",
      OverBracket: "",
      OverParenthesis: "",
      par: "",
      para: "",
      parallel: "",
      parsim: "",
      parsl: "",
      part: "",
      PartialD: "",
      Pcy: "",
      pcy: "",
      percnt: "%",
      period: ".",
      permil: "",
      perp: "",
      pertenk: "",
      Pfr: "",
      pfr: "",
      Phi: "",
      phi: "",
      phiv: "",
      phmmat: "",
      phone: "",
      Pi: "",
      pi: "",
      pitchfork: "",
      piv: "",
      planck: "",
      planckh: "",
      plankv: "",
      plus: "+",
      plusacir: "",
      plusb: "",
      pluscir: "",
      plusdo: "",
      plusdu: "",
      pluse: "",
      PlusMinus: "",
      plusmn: "",
      plussim: "",
      plustwo: "",
      pm: "",
      Poincareplane: "",
      pointint: "",
      Popf: "",
      popf: "",
      pound: "",
      Pr: "",
      pr: "",
      prap: "",
      prcue: "",
      prE: "",
      pre: "",
      prec: "",
      precapprox: "",
      preccurlyeq: "",
      Precedes: "",
      PrecedesEqual: "",
      PrecedesSlantEqual: "",
      PrecedesTilde: "",
      preceq: "",
      precnapprox: "",
      precneqq: "",
      precnsim: "",
      precsim: "",
      Prime: "",
      prime: "",
      primes: "",
      prnap: "",
      prnE: "",
      prnsim: "",
      prod: "",
      Product: "",
      profalar: "",
      profline: "",
      profsurf: "",
      prop: "",
      Proportion: "",
      Proportional: "",
      propto: "",
      prsim: "",
      prurel: "",
      Pscr: "",
      pscr: "",
      Psi: "",
      psi: "",
      puncsp: "",
      Qfr: "",
      qfr: "",
      qint: "",
      Qopf: "",
      qopf: "",
      qprime: "",
      Qscr: "",
      qscr: "",
      quaternions: "",
      quatint: "",
      quest: "?",
      questeq: "",
      QUOT: '"',
      quot: '"',
      rAarr: "",
      race: "",
      Racute: "",
      racute: "",
      radic: "",
      raemptyv: "",
      Rang: "",
      rang: "",
      rangd: "",
      range: "",
      rangle: "",
      raquo: "",
      Rarr: "",
      rArr: "",
      rarr: "",
      rarrap: "",
      rarrb: "",
      rarrbfs: "",
      rarrc: "",
      rarrfs: "",
      rarrhk: "",
      rarrlp: "",
      rarrpl: "",
      rarrsim: "",
      Rarrtl: "",
      rarrtl: "",
      rarrw: "",
      rAtail: "",
      ratail: "",
      ratio: "",
      rationals: "",
      RBarr: "",
      rBarr: "",
      rbarr: "",
      rbbrk: "",
      rbrace: "}",
      rbrack: "]",
      rbrke: "",
      rbrksld: "",
      rbrkslu: "",
      Rcaron: "",
      rcaron: "",
      Rcedil: "",
      rcedil: "",
      rceil: "",
      rcub: "}",
      Rcy: "",
      rcy: "",
      rdca: "",
      rdldhar: "",
      rdquo: "",
      rdquor: "",
      rdsh: "",
      Re: "",
      real: "",
      realine: "",
      realpart: "",
      reals: "",
      rect: "",
      REG: "",
      reg: "",
      ReverseElement: "",
      ReverseEquilibrium: "",
      ReverseUpEquilibrium: "",
      rfisht: "",
      rfloor: "",
      Rfr: "",
      rfr: "",
      rHar: "",
      rhard: "",
      rharu: "",
      rharul: "",
      Rho: "",
      rho: "",
      rhov: "",
      RightAngleBracket: "",
      RightArrow: "",
      Rightarrow: "",
      rightarrow: "",
      RightArrowBar: "",
      RightArrowLeftArrow: "",
      rightarrowtail: "",
      RightCeiling: "",
      RightDoubleBracket: "",
      RightDownTeeVector: "",
      RightDownVector: "",
      RightDownVectorBar: "",
      RightFloor: "",
      rightharpoondown: "",
      rightharpoonup: "",
      rightleftarrows: "",
      rightleftharpoons: "",
      rightrightarrows: "",
      rightsquigarrow: "",
      RightTee: "",
      RightTeeArrow: "",
      RightTeeVector: "",
      rightthreetimes: "",
      RightTriangle: "",
      RightTriangleBar: "",
      RightTriangleEqual: "",
      RightUpDownVector: "",
      RightUpTeeVector: "",
      RightUpVector: "",
      RightUpVectorBar: "",
      RightVector: "",
      RightVectorBar: "",
      ring: "",
      risingdotseq: "",
      rlarr: "",
      rlhar: "",
      rlm: "",
      rmoust: "",
      rmoustache: "",
      rnmid: "",
      roang: "",
      roarr: "",
      robrk: "",
      ropar: "",
      Ropf: "",
      ropf: "",
      roplus: "",
      rotimes: "",
      RoundImplies: "",
      rpar: ")",
      rpargt: "",
      rppolint: "",
      rrarr: "",
      Rrightarrow: "",
      rsaquo: "",
      Rscr: "",
      rscr: "",
      Rsh: "",
      rsh: "",
      rsqb: "]",
      rsquo: "",
      rsquor: "",
      rthree: "",
      rtimes: "",
      rtri: "",
      rtrie: "",
      rtrif: "",
      rtriltri: "",
      RuleDelayed: "",
      ruluhar: "",
      rx: "",
      Sacute: "",
      sacute: "",
      sbquo: "",
      Sc: "",
      sc: "",
      scap: "",
      Scaron: "",
      scaron: "",
      sccue: "",
      scE: "",
      sce: "",
      Scedil: "",
      scedil: "",
      Scirc: "",
      scirc: "",
      scnap: "",
      scnE: "",
      scnsim: "",
      scpolint: "",
      scsim: "",
      Scy: "",
      scy: "",
      sdot: "",
      sdotb: "",
      sdote: "",
      searhk: "",
      seArr: "",
      searr: "",
      searrow: "",
      sect: "",
      semi: ";",
      seswar: "",
      setminus: "",
      setmn: "",
      sext: "",
      Sfr: "",
      sfr: "",
      sfrown: "",
      sharp: "",
      SHCHcy: "",
      shchcy: "",
      SHcy: "",
      shcy: "",
      ShortDownArrow: "",
      ShortLeftArrow: "",
      shortmid: "",
      shortparallel: "",
      ShortRightArrow: "",
      ShortUpArrow: "",
      shy: "",
      Sigma: "",
      sigma: "",
      sigmaf: "",
      sigmav: "",
      sim: "",
      simdot: "",
      sime: "",
      simeq: "",
      simg: "",
      simgE: "",
      siml: "",
      simlE: "",
      simne: "",
      simplus: "",
      simrarr: "",
      slarr: "",
      SmallCircle: "",
      smallsetminus: "",
      smashp: "",
      smeparsl: "",
      smid: "",
      smile: "",
      smt: "",
      smte: "",
      smtes: "",
      SOFTcy: "",
      softcy: "",
      sol: "/",
      solb: "",
      solbar: "",
      Sopf: "",
      sopf: "",
      spades: "",
      spadesuit: "",
      spar: "",
      sqcap: "",
      sqcaps: "",
      sqcup: "",
      sqcups: "",
      Sqrt: "",
      sqsub: "",
      sqsube: "",
      sqsubset: "",
      sqsubseteq: "",
      sqsup: "",
      sqsupe: "",
      sqsupset: "",
      sqsupseteq: "",
      squ: "",
      Square: "",
      square: "",
      SquareIntersection: "",
      SquareSubset: "",
      SquareSubsetEqual: "",
      SquareSuperset: "",
      SquareSupersetEqual: "",
      SquareUnion: "",
      squarf: "",
      squf: "",
      srarr: "",
      Sscr: "",
      sscr: "",
      ssetmn: "",
      ssmile: "",
      sstarf: "",
      Star: "",
      star: "",
      starf: "",
      straightepsilon: "",
      straightphi: "",
      strns: "",
      Sub: "",
      sub: "",
      subdot: "",
      subE: "",
      sube: "",
      subedot: "",
      submult: "",
      subnE: "",
      subne: "",
      subplus: "",
      subrarr: "",
      Subset: "",
      subset: "",
      subseteq: "",
      subseteqq: "",
      SubsetEqual: "",
      subsetneq: "",
      subsetneqq: "",
      subsim: "",
      subsub: "",
      subsup: "",
      succ: "",
      succapprox: "",
      succcurlyeq: "",
      Succeeds: "",
      SucceedsEqual: "",
      SucceedsSlantEqual: "",
      SucceedsTilde: "",
      succeq: "",
      succnapprox: "",
      succneqq: "",
      succnsim: "",
      succsim: "",
      SuchThat: "",
      Sum: "",
      sum: "",
      sung: "",
      Sup: "",
      sup: "",
      sup1: "",
      sup2: "",
      sup3: "",
      supdot: "",
      supdsub: "",
      supE: "",
      supe: "",
      supedot: "",
      Superset: "",
      SupersetEqual: "",
      suphsol: "",
      suphsub: "",
      suplarr: "",
      supmult: "",
      supnE: "",
      supne: "",
      supplus: "",
      Supset: "",
      supset: "",
      supseteq: "",
      supseteqq: "",
      supsetneq: "",
      supsetneqq: "",
      supsim: "",
      supsub: "",
      supsup: "",
      swarhk: "",
      swArr: "",
      swarr: "",
      swarrow: "",
      swnwar: "",
      szlig: "",
      Tab: "	",
      target: "",
      Tau: "",
      tau: "",
      tbrk: "",
      Tcaron: "",
      tcaron: "",
      Tcedil: "",
      tcedil: "",
      Tcy: "",
      tcy: "",
      tdot: "",
      telrec: "",
      Tfr: "",
      tfr: "",
      there4: "",
      Therefore: "",
      therefore: "",
      Theta: "",
      theta: "",
      thetasym: "",
      thetav: "",
      thickapprox: "",
      thicksim: "",
      ThickSpace: "",
      thinsp: "",
      ThinSpace: "",
      thkap: "",
      thksim: "",
      THORN: "",
      thorn: "",
      Tilde: "",
      tilde: "",
      TildeEqual: "",
      TildeFullEqual: "",
      TildeTilde: "",
      times: "",
      timesb: "",
      timesbar: "",
      timesd: "",
      tint: "",
      toea: "",
      top: "",
      topbot: "",
      topcir: "",
      Topf: "",
      topf: "",
      topfork: "",
      tosa: "",
      tprime: "",
      TRADE: "",
      trade: "",
      triangle: "",
      triangledown: "",
      triangleleft: "",
      trianglelefteq: "",
      triangleq: "",
      triangleright: "",
      trianglerighteq: "",
      tridot: "",
      trie: "",
      triminus: "",
      TripleDot: "",
      triplus: "",
      trisb: "",
      tritime: "",
      trpezium: "",
      Tscr: "",
      tscr: "",
      TScy: "",
      tscy: "",
      TSHcy: "",
      tshcy: "",
      Tstrok: "",
      tstrok: "",
      twixt: "",
      twoheadleftarrow: "",
      twoheadrightarrow: "",
      Uacute: "",
      uacute: "",
      Uarr: "",
      uArr: "",
      uarr: "",
      Uarrocir: "",
      Ubrcy: "",
      ubrcy: "",
      Ubreve: "",
      ubreve: "",
      Ucirc: "",
      ucirc: "",
      Ucy: "",
      ucy: "",
      udarr: "",
      Udblac: "",
      udblac: "",
      udhar: "",
      ufisht: "",
      Ufr: "",
      ufr: "",
      Ugrave: "",
      ugrave: "",
      uHar: "",
      uharl: "",
      uharr: "",
      uhblk: "",
      ulcorn: "",
      ulcorner: "",
      ulcrop: "",
      ultri: "",
      Umacr: "",
      umacr: "",
      uml: "",
      UnderBar: "_",
      UnderBrace: "",
      UnderBracket: "",
      UnderParenthesis: "",
      Union: "",
      UnionPlus: "",
      Uogon: "",
      uogon: "",
      Uopf: "",
      uopf: "",
      UpArrow: "",
      Uparrow: "",
      uparrow: "",
      UpArrowBar: "",
      UpArrowDownArrow: "",
      UpDownArrow: "",
      Updownarrow: "",
      updownarrow: "",
      UpEquilibrium: "",
      upharpoonleft: "",
      upharpoonright: "",
      uplus: "",
      UpperLeftArrow: "",
      UpperRightArrow: "",
      Upsi: "",
      upsi: "",
      upsih: "",
      Upsilon: "",
      upsilon: "",
      UpTee: "",
      UpTeeArrow: "",
      upuparrows: "",
      urcorn: "",
      urcorner: "",
      urcrop: "",
      Uring: "",
      uring: "",
      urtri: "",
      Uscr: "",
      uscr: "",
      utdot: "",
      Utilde: "",
      utilde: "",
      utri: "",
      utrif: "",
      uuarr: "",
      Uuml: "",
      uuml: "",
      uwangle: "",
      vangrt: "",
      varepsilon: "",
      varkappa: "",
      varnothing: "",
      varphi: "",
      varpi: "",
      varpropto: "",
      vArr: "",
      varr: "",
      varrho: "",
      varsigma: "",
      varsubsetneq: "",
      varsubsetneqq: "",
      varsupsetneq: "",
      varsupsetneqq: "",
      vartheta: "",
      vartriangleleft: "",
      vartriangleright: "",
      Vbar: "",
      vBar: "",
      vBarv: "",
      Vcy: "",
      vcy: "",
      VDash: "",
      Vdash: "",
      vDash: "",
      vdash: "",
      Vdashl: "",
      Vee: "",
      vee: "",
      veebar: "",
      veeeq: "",
      vellip: "",
      Verbar: "",
      verbar: "|",
      Vert: "",
      vert: "|",
      VerticalBar: "",
      VerticalLine: "|",
      VerticalSeparator: "",
      VerticalTilde: "",
      VeryThinSpace: "",
      Vfr: "",
      vfr: "",
      vltri: "",
      vnsub: "",
      vnsup: "",
      Vopf: "",
      vopf: "",
      vprop: "",
      vrtri: "",
      Vscr: "",
      vscr: "",
      vsubnE: "",
      vsubne: "",
      vsupnE: "",
      vsupne: "",
      Vvdash: "",
      vzigzag: "",
      Wcirc: "",
      wcirc: "",
      wedbar: "",
      Wedge: "",
      wedge: "",
      wedgeq: "",
      weierp: "",
      Wfr: "",
      wfr: "",
      Wopf: "",
      wopf: "",
      wp: "",
      wr: "",
      wreath: "",
      Wscr: "",
      wscr: "",
      xcap: "",
      xcirc: "",
      xcup: "",
      xdtri: "",
      Xfr: "",
      xfr: "",
      xhArr: "",
      xharr: "",
      Xi: "",
      xi: "",
      xlArr: "",
      xlarr: "",
      xmap: "",
      xnis: "",
      xodot: "",
      Xopf: "",
      xopf: "",
      xoplus: "",
      xotime: "",
      xrArr: "",
      xrarr: "",
      Xscr: "",
      xscr: "",
      xsqcup: "",
      xuplus: "",
      xutri: "",
      xvee: "",
      xwedge: "",
      Yacute: "",
      yacute: "",
      YAcy: "",
      yacy: "",
      Ycirc: "",
      ycirc: "",
      Ycy: "",
      ycy: "",
      yen: "",
      Yfr: "",
      yfr: "",
      YIcy: "",
      yicy: "",
      Yopf: "",
      yopf: "",
      Yscr: "",
      yscr: "",
      YUcy: "",
      yucy: "",
      Yuml: "",
      yuml: "",
      Zacute: "",
      zacute: "",
      Zcaron: "",
      zcaron: "",
      Zcy: "",
      zcy: "",
      Zdot: "",
      zdot: "",
      zeetrf: "",
      ZeroWidthSpace: "",
      Zeta: "",
      zeta: "",
      Zfr: "",
      zfr: "",
      ZHcy: "",
      zhcy: "",
      zigrarr: "",
      Zopf: "",
      zopf: "",
      Zscr: "",
      zscr: "",
      zwj: "",
      zwnj: ""
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser2;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/abab/lib/atob.js
var require_atob = __commonJS({
  "node_modules/abab/lib/atob.js"(exports, module) {
    "use strict";
    function atob3(data) {
      if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      data = `${data}`;
      data = data.replace(/[ \t\n\f\r]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/==?$/, "");
      }
      if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {
        return null;
      }
      let output = "";
      let buffer = 0;
      let accumulatedBits = 0;
      for (let i = 0; i < data.length; i++) {
        buffer <<= 6;
        buffer |= atobLookup(data[i]);
        accumulatedBits += 6;
        if (accumulatedBits === 24) {
          output += String.fromCharCode((buffer & 16711680) >> 16);
          output += String.fromCharCode((buffer & 65280) >> 8);
          output += String.fromCharCode(buffer & 255);
          buffer = accumulatedBits = 0;
        }
      }
      if (accumulatedBits === 12) {
        buffer >>= 4;
        output += String.fromCharCode(buffer);
      } else if (accumulatedBits === 18) {
        buffer >>= 2;
        output += String.fromCharCode((buffer & 65280) >> 8);
        output += String.fromCharCode(buffer & 255);
      }
      return output;
    }
    var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function atobLookup(chr) {
      const index = keystr.indexOf(chr);
      return index < 0 ? void 0 : index;
    }
    module.exports = atob3;
  }
});

// node_modules/abab/lib/btoa.js
var require_btoa = __commonJS({
  "node_modules/abab/lib/btoa.js"(exports, module) {
    "use strict";
    function btoa3(s) {
      if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      let i;
      s = `${s}`;
      for (i = 0; i < s.length; i++) {
        if (s.charCodeAt(i) > 255) {
          return null;
        }
      }
      let out = "";
      for (i = 0; i < s.length; i += 3) {
        const groupsOfSix = [void 0, void 0, void 0, void 0];
        groupsOfSix[0] = s.charCodeAt(i) >> 2;
        groupsOfSix[1] = (s.charCodeAt(i) & 3) << 4;
        if (s.length > i + 1) {
          groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;
          groupsOfSix[2] = (s.charCodeAt(i + 1) & 15) << 2;
        }
        if (s.length > i + 2) {
          groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;
          groupsOfSix[3] = s.charCodeAt(i + 2) & 63;
        }
        for (let j = 0; j < groupsOfSix.length; j++) {
          if (typeof groupsOfSix[j] === "undefined") {
            out += "=";
          } else {
            out += btoaLookup(groupsOfSix[j]);
          }
        }
      }
      return out;
    }
    var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function btoaLookup(index) {
      if (index >= 0 && index < 64) {
        return keystr[index];
      }
      return void 0;
    }
    module.exports = btoa3;
  }
});

// node_modules/abab/index.js
var require_abab = __commonJS({
  "node_modules/abab/index.js"(exports, module) {
    "use strict";
    var atob3 = require_atob();
    var btoa3 = require_btoa();
    module.exports = {
      atob: atob3,
      btoa: btoa3
    };
  }
});

// node_modules/strophe.js/src/shims.js
var shims_exports = {};
__export(shims_exports, {
  DOMParser: () => DOMParser,
  WebSocket: () => WebSocket,
  getDummyXMLDOMDocument: () => getDummyXMLDOMDocument
});
function getWebSocketImplementation() {
  if (typeof globalThis.WebSocket === "undefined") {
    try {
      return require_browser();
    } catch (err) {
      throw new Error('You must install the "ws" package to use Strophe in nodejs.');
    }
  }
  return globalThis.WebSocket;
}
var WebSocket = getWebSocketImplementation();
function getDOMParserImplementation() {
  let DOMParserImplementation = globalThis.DOMParser;
  if (typeof DOMParserImplementation === "undefined") {
    try {
      DOMParserImplementation = require_lib().DOMParser;
    } catch (err) {
      throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
    }
  }
  return DOMParserImplementation;
}
var DOMParser = getDOMParserImplementation();
function getDummyXMLDOMDocument() {
  if (typeof document === "undefined") {
    try {
      const DOMImplementation = require_lib().DOMImplementation;
      return new DOMImplementation().createDocument("jabber:client", "strophe", null);
    } catch (err) {
      throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
    }
  }
  return document.implementation.createDocument("jabber:client", "strophe", null);
}

// node_modules/strophe.js/src/utils.js
var utils_exports = {};
__export(utils_exports, {
  addCookies: () => addCookies,
  arrayBufToBase64: () => arrayBufToBase64,
  base64ToArrayBuf: () => base64ToArrayBuf,
  copyElement: () => copyElement,
  createHtml: () => createHtml,
  default: () => utils,
  escapeNode: () => escapeNode,
  forEachChild: () => forEachChild,
  getBareJidFromJid: () => getBareJidFromJid,
  getDomainFromJid: () => getDomainFromJid,
  getNodeFromJid: () => getNodeFromJid,
  getResourceFromJid: () => getResourceFromJid,
  getText: () => getText,
  handleError: () => handleError,
  isTagEqual: () => isTagEqual,
  stringToArrayBuf: () => stringToArrayBuf,
  unescapeNode: () => unescapeNode,
  utf16to8: () => utf16to8,
  validAttribute: () => validAttribute,
  validCSS: () => validCSS,
  validTag: () => validTag,
  xmlElement: () => xmlElement,
  xmlGenerator: () => xmlGenerator,
  xmlHtmlNode: () => xmlHtmlNode,
  xmlTextNode: () => xmlTextNode,
  xmlescape: () => xmlescape,
  xmlunescape: () => xmlunescape,
  xorArrayBuffers: () => xorArrayBuffers
});

// node_modules/strophe.js/src/constants.js
var NS = {
  HTTPBIND: "http://jabber.org/protocol/httpbind",
  BOSH: "urn:xmpp:xbosh",
  CLIENT: "jabber:client",
  AUTH: "jabber:iq:auth",
  ROSTER: "jabber:iq:roster",
  PROFILE: "jabber:iq:profile",
  DISCO_INFO: "http://jabber.org/protocol/disco#info",
  DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
  MUC: "http://jabber.org/protocol/muc",
  SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
  STREAM: "http://etherx.jabber.org/streams",
  FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
  BIND: "urn:ietf:params:xml:ns:xmpp-bind",
  SESSION: "urn:ietf:params:xml:ns:xmpp-session",
  VERSION: "jabber:iq:version",
  STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
  XHTML_IM: "http://jabber.org/protocol/xhtml-im",
  XHTML: "http://www.w3.org/1999/xhtml"
};
var XHTML = {
  tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
  attributes: {
    "a": ["href"],
    "blockquote": ["style"],
    /** @type {never[]} */
    "br": [],
    "cite": ["style"],
    /** @type {never[]} */
    "em": [],
    "img": ["src", "alt", "style", "height", "width"],
    "li": ["style"],
    "ol": ["style"],
    "p": ["style"],
    "span": ["style"],
    /** @type {never[]} */
    "strong": [],
    "ul": ["style"],
    /** @type {never[]} */
    "body": []
  },
  css: [
    "background-color",
    "color",
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "margin-left",
    "margin-right",
    "text-align",
    "text-decoration"
  ]
};
var Status = {
  ERROR: 0,
  CONNECTING: 1,
  CONNFAIL: 2,
  AUTHENTICATING: 3,
  AUTHFAIL: 4,
  CONNECTED: 5,
  DISCONNECTED: 6,
  DISCONNECTING: 7,
  ATTACHED: 8,
  REDIRECT: 9,
  CONNTIMEOUT: 10,
  BINDREQUIRED: 11,
  ATTACHFAIL: 12,
  RECONNECTING: 13
};
var ErrorCondition = {
  BAD_FORMAT: "bad-format",
  CONFLICT: "conflict",
  MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
  NO_AUTH_MECH: "no-auth-mech",
  UNKNOWN_REASON: "unknown"
};
var LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4
};
var ElementType = {
  NORMAL: 1,
  TEXT: 3,
  CDATA: 4,
  FRAGMENT: 11
};

// node_modules/strophe.js/src/log.js
var logLevel = LOG_LEVELS.DEBUG;
var log = {
  /**
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    if (level < LOG_LEVELS.DEBUG || level > LOG_LEVELS.FATAL) {
      throw new Error("Invalid log level supplied to setLogLevel");
    }
    logLevel = level;
  },
  /**
   *
   * Please note that data sent and received over the wire is logged
   * via {@link Strophe.Connection#rawInput|Strophe.Connection.rawInput()}
   * and {@link Strophe.Connection#rawOutput|Strophe.Connection.rawOutput()}.
   *
   * The different levels and their meanings are
   *
   *   DEBUG - Messages useful for debugging purposes.
   *   INFO - Informational messages.  This is mostly information like
   *     'disconnect was called' or 'SASL auth succeeded'.
   *   WARN - Warnings about potential problems.  This is mostly used
   *     to report transient connection errors like request timeouts.
   *   ERROR - Some error occurred.
   *   FATAL - A non-recoverable fatal error occurred.
   *
   * @param {number} level - The log level of the log message.
   *     This will be one of the values in Strophe.LOG_LEVELS.
   * @param {string} msg - The log message.
   */
  log(level, msg) {
    if (level < logLevel) {
      return;
    }
    if (level >= LOG_LEVELS.ERROR) {
      console == null ? void 0 : console.error(msg);
    } else if (level === LOG_LEVELS.INFO) {
      console == null ? void 0 : console.info(msg);
    } else if (level === LOG_LEVELS.WARN) {
      console == null ? void 0 : console.warn(msg);
    } else if (level === LOG_LEVELS.DEBUG) {
      console == null ? void 0 : console.debug(msg);
    }
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.DEBUG level.
   * @param {string} msg - The log message.
   */
  debug(msg) {
    this.log(LOG_LEVELS.DEBUG, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.INFO level.
   * @param {string} msg - The log message.
   */
  info(msg) {
    this.log(LOG_LEVELS.INFO, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.WARN level.
   * @param {string} msg - The log message.
   */
  warn(msg) {
    this.log(LOG_LEVELS.WARN, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.ERROR level.
   * @param {string} msg - The log message.
   */
  error(msg) {
    this.log(LOG_LEVELS.ERROR, msg);
  },
  /**
   * Log a message at the Strophe.LOG_LEVELS.FATAL level.
   * @param {string} msg - The log message.
   */
  fatal(msg) {
    this.log(LOG_LEVELS.FATAL, msg);
  }
};
var log_default = log;

// node_modules/strophe.js/src/utils.js
function handleError(e) {
  if (typeof e.stack !== "undefined") {
    log_default.fatal(e.stack);
  }
  log_default.fatal("error: " + e.message);
}
function utf16to8(str) {
  let out = "";
  const len = str.length;
  for (let i = 0; i < len; i++) {
    const c = str.charCodeAt(i);
    if (c >= 0 && c <= 127) {
      out += str.charAt(i);
    } else if (c > 2047) {
      out += String.fromCharCode(224 | c >> 12 & 15);
      out += String.fromCharCode(128 | c >> 6 & 63);
      out += String.fromCharCode(128 | c >> 0 & 63);
    } else {
      out += String.fromCharCode(192 | c >> 6 & 31);
      out += String.fromCharCode(128 | c >> 0 & 63);
    }
  }
  return out;
}
function xorArrayBuffers(x, y) {
  const xIntArray = new Uint8Array(x);
  const yIntArray = new Uint8Array(y);
  const zIntArray = new Uint8Array(x.byteLength);
  for (let i = 0; i < x.byteLength; i++) {
    zIntArray[i] = xIntArray[i] ^ yIntArray[i];
  }
  return zIntArray.buffer;
}
function arrayBufToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToArrayBuf(str) {
  var _a;
  return (_a = Uint8Array.from(atob(str), (c) => c.charCodeAt(0))) == null ? void 0 : _a.buffer;
}
function stringToArrayBuf(str) {
  const bytes = new TextEncoder().encode(str);
  return bytes.buffer;
}
function addCookies(cookies) {
  if (typeof document === "undefined") {
    log_default.error(`addCookies: not adding any cookies, since there's no document object`);
  }
  cookies = cookies || {};
  for (const cookieName in cookies) {
    if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {
      let expires = "";
      let domain = "";
      let path = "";
      const cookieObj = cookies[cookieName];
      const isObj = typeof cookieObj === "object";
      const cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
      if (isObj) {
        expires = cookieObj.expires ? ";expires=" + cookieObj.expires : "";
        domain = cookieObj.domain ? ";domain=" + cookieObj.domain : "";
        path = cookieObj.path ? ";path=" + cookieObj.path : "";
      }
      document.cookie = cookieName + "=" + cookieValue + expires + domain + path;
    }
  }
}
var _xmlGenerator = null;
function xmlGenerator() {
  if (!_xmlGenerator) {
    _xmlGenerator = getDummyXMLDOMDocument();
  }
  return _xmlGenerator;
}
function xmlTextNode(text) {
  return xmlGenerator().createTextNode(text);
}
function xmlHtmlNode(html) {
  const parser = new DOMParser();
  return parser.parseFromString(html, "text/xml");
}
function xmlElement(name, attrs, text) {
  if (!name) return null;
  const node = xmlGenerator().createElement(name);
  if (text && (typeof text === "string" || typeof text === "number")) {
    node.appendChild(xmlTextNode(text.toString()));
  } else if (typeof attrs === "string" || typeof attrs === "number") {
    node.appendChild(xmlTextNode(
      /** @type {number|string} */
      attrs.toString()
    ));
    return node;
  }
  if (!attrs) {
    return node;
  } else if (Array.isArray(attrs)) {
    for (const attr of attrs) {
      if (Array.isArray(attr)) {
        if (attr[0] != null && attr[1] != null) {
          node.setAttribute(attr[0], attr[1]);
        }
      }
    }
  } else if (typeof attrs === "object") {
    for (const k of Object.keys(attrs)) {
      if (k && attrs[k] != null) {
        node.setAttribute(k, attrs[k].toString());
      }
    }
  }
  return node;
}
function validTag(tag) {
  for (let i = 0; i < XHTML.tags.length; i++) {
    if (tag === XHTML.tags[i]) {
      return true;
    }
  }
  return false;
}
function validAttribute(tag, attribute) {
  const attrs = XHTML.attributes[
    /** @type {XHTMLAttrs} */
    tag
  ];
  if ((attrs == null ? void 0 : attrs.length) > 0) {
    for (let i = 0; i < attrs.length; i++) {
      if (attribute === attrs[i]) {
        return true;
      }
    }
  }
  return false;
}
function validCSS(style) {
  for (let i = 0; i < XHTML.css.length; i++) {
    if (style === XHTML.css[i]) {
      return true;
    }
  }
  return false;
}
function createFromHtmlElement(elem) {
  let el;
  const tag = elem.nodeName.toLowerCase();
  if (validTag(tag)) {
    try {
      el = xmlElement(tag);
      if (tag in XHTML.attributes) {
        const attrs = XHTML.attributes[
          /** @type {XHTMLAttrs} */
          tag
        ];
        for (let i = 0; i < attrs.length; i++) {
          const attribute = attrs[i];
          let value = elem.getAttribute(attribute);
          if (typeof value === "undefined" || value === null || value === "") {
            continue;
          }
          if (attribute === "style" && typeof value === "object") {
            value = /** @type {Object.<'csstext',string>} */
            value.cssText ?? value;
          }
          if (attribute === "style") {
            const css = [];
            const cssAttrs = value.split(";");
            for (let j = 0; j < cssAttrs.length; j++) {
              const attr = cssAttrs[j].split(":");
              const cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
              if (validCSS(cssName)) {
                const cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                css.push(cssName + ": " + cssValue);
              }
            }
            if (css.length > 0) {
              value = css.join("; ");
              el.setAttribute(attribute, value);
            }
          } else {
            el.setAttribute(attribute, value);
          }
        }
        for (let i = 0; i < elem.childNodes.length; i++) {
          el.appendChild(createHtml(elem.childNodes[i]));
        }
      }
    } catch (e) {
      el = xmlTextNode("");
    }
  } else {
    el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < elem.childNodes.length; i++) {
      el.appendChild(createHtml(elem.childNodes[i]));
    }
  }
  return el;
}
function createHtml(node) {
  if (node.nodeType === ElementType.NORMAL) {
    return createFromHtmlElement(
      /** @type {HTMLElement} */
      node
    );
  } else if (node.nodeType === ElementType.FRAGMENT) {
    const el = xmlGenerator().createDocumentFragment();
    for (let i = 0; i < node.childNodes.length; i++) {
      el.appendChild(createHtml(node.childNodes[i]));
    }
    return el;
  } else if (node.nodeType === ElementType.TEXT) {
    return xmlTextNode(node.nodeValue);
  }
}
function copyElement(node) {
  let out;
  if (node.nodeType === ElementType.NORMAL) {
    const el = (
      /** @type {Element} */
      node
    );
    out = xmlElement(el.tagName);
    for (let i = 0; i < el.attributes.length; i++) {
      out.setAttribute(el.attributes[i].nodeName, el.attributes[i].value);
    }
    for (let i = 0; i < el.childNodes.length; i++) {
      out.appendChild(copyElement(el.childNodes[i]));
    }
  } else if (node.nodeType === ElementType.TEXT) {
    out = xmlGenerator().createTextNode(node.nodeValue);
  }
  return out;
}
function xmlescape(text) {
  text = text.replace(/\&/g, "&amp;");
  text = text.replace(/</g, "&lt;");
  text = text.replace(/>/g, "&gt;");
  text = text.replace(/'/g, "&apos;");
  text = text.replace(/"/g, "&quot;");
  return text;
}
function xmlunescape(text) {
  text = text.replace(/\&amp;/g, "&");
  text = text.replace(/&lt;/g, "<");
  text = text.replace(/&gt;/g, ">");
  text = text.replace(/&apos;/g, "'");
  text = text.replace(/&quot;/g, '"');
  return text;
}
function forEachChild(elem, elemName, func) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
      func(childNode);
    }
  }
}
function isTagEqual(el, name) {
  return el.tagName === name;
}
function getText(elem) {
  var _a, _b;
  if (!elem) {
    return null;
  }
  let str = "";
  if (!((_a = elem.childNodes) == null ? void 0 : _a.length) && elem.nodeType === ElementType.TEXT) {
    str += elem.nodeValue;
  }
  for (let i = 0; i < ((_b = elem.childNodes) == null ? void 0 : _b.length); i++) {
    if (elem.childNodes[i].nodeType === ElementType.TEXT) {
      str += elem.childNodes[i].nodeValue;
    }
  }
  return xmlescape(str);
}
function escapeNode(node) {
  if (typeof node !== "string") {
    return node;
  }
  return node.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40");
}
function unescapeNode(node) {
  if (typeof node !== "string") {
    return node;
  }
  return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\");
}
function getNodeFromJid(jid) {
  if (jid.indexOf("@") < 0) {
    return null;
  }
  return jid.split("@")[0];
}
function getDomainFromJid(jid) {
  const bare = getBareJidFromJid(jid);
  if (bare.indexOf("@") < 0) {
    return bare;
  } else {
    const parts = bare.split("@");
    parts.splice(0, 1);
    return parts.join("@");
  }
}
function getResourceFromJid(jid) {
  if (!jid) {
    return null;
  }
  const s = jid.split("/");
  if (s.length < 2) {
    return null;
  }
  s.splice(0, 1);
  return s.join("/");
}
function getBareJidFromJid(jid) {
  return jid ? jid.split("/")[0] : null;
}
var utils = {
  utf16to8,
  xorArrayBuffers,
  arrayBufToBase64,
  base64ToArrayBuf,
  stringToArrayBuf,
  addCookies
};

// node_modules/strophe.js/src/builder.js
function $build(name, attrs) {
  return new Builder(name, attrs);
}
function $msg(attrs) {
  return new Builder("message", attrs);
}
function $iq(attrs) {
  return new Builder("iq", attrs);
}
function $pres(attrs) {
  return new Builder("presence", attrs);
}
var Builder = class _Builder {
  /**
   * @typedef {Object.<string, string|number>} StanzaAttrs
   * @property {string} [StanzaAttrs.xmlns]
   */
  /**
   * The attributes should be passed in object notation.
   * @param {string} name - The name of the root element.
   * @param {StanzaAttrs} [attrs] - The attributes for the root element in object notation.
   * @example const b = new Builder('message', {to: 'you', from: 'me'});
   * @example const b = new Builder('messsage', {'xml:lang': 'en'});
   */
  constructor(name, attrs) {
    if (name === "presence" || name === "message" || name === "iq") {
      if (attrs && !attrs.xmlns) {
        attrs.xmlns = NS.CLIENT;
      } else if (!attrs) {
        attrs = { xmlns: NS.CLIENT };
      }
    }
    this.nodeTree = xmlElement(name, attrs);
    this.node = this.nodeTree;
  }
  /**
   * Render a DOM element and all descendants to a String.
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  static serialize(elem) {
    if (!elem) return null;
    const el = elem instanceof _Builder ? elem.tree() : elem;
    const names = [...Array(el.attributes.length).keys()].map((i) => el.attributes[i].nodeName);
    names.sort();
    let result = names.reduce(
      (a, n) => `${a} ${n}="${xmlescape(el.attributes.getNamedItem(n).value)}"`,
      `<${el.nodeName}`
    );
    if (el.childNodes.length > 0) {
      result += ">";
      for (let i = 0; i < el.childNodes.length; i++) {
        const child = el.childNodes[i];
        switch (child.nodeType) {
          case ElementType.NORMAL:
            result += _Builder.serialize(
              /** @type {Element} */
              child
            );
            break;
          case ElementType.TEXT:
            result += xmlescape(child.nodeValue);
            break;
          case ElementType.CDATA:
            result += "<![CDATA[" + child.nodeValue + "]]>";
        }
      }
      result += "</" + el.nodeName + ">";
    } else {
      result += "/>";
    }
    return result;
  }
  /**
   * Return the DOM tree.
   *
   * This function returns the current DOM tree as an element object.  This
   * is suitable for passing to functions like Strophe.Connection.send().
   *
   * @return {Element} The DOM tree as a element object.
   */
  tree() {
    return this.nodeTree;
  }
  /**
   * Serialize the DOM tree to a String.
   *
   * This function returns a string serialization of the current DOM
   * tree.  It is often used internally to pass data to a
   * Strophe.Request object.
   *
   * @return {string} The serialized DOM tree in a String.
   */
  toString() {
    return _Builder.serialize(this.nodeTree);
  }
  /**
   * Make the current parent element the new current element.
   * This function is often used after c() to traverse back up the tree.
   *
   * @example
   *  // For example, to add two children to the same element
   *  builder.c('child1', {}).up().c('child2', {});
   *
   * @return {Builder} The Strophe.Builder object.
   */
  up() {
    this.node = this.node.parentElement ? this.node.parentElement : (
      /** @type {Element} */
      this.node.parentNode
    );
    return this;
  }
  /**
   * Make the root element the new current element.
   *
   * When at a deeply nested element in the tree, this function can be used
   * to jump back to the root of the tree, instead of having to repeatedly
   * call up().
   *
   * @return {Builder} The Strophe.Builder object.
   */
  root() {
    this.node = this.nodeTree;
    return this;
  }
  /**
   * Add or modify attributes of the current element.
   *
   * The attributes should be passed in object notation.
   * This function does not move the current element pointer.
   * @param {Object.<string, string|number|null>} moreattrs - The attributes to add/modify in object notation.
   *  If an attribute is set to `null` or `undefined`, it will be removed.
   * @return {Builder} The Strophe.Builder object.
   */
  attrs(moreattrs) {
    for (const k in moreattrs) {
      if (Object.prototype.hasOwnProperty.call(moreattrs, k)) {
        if (moreattrs[k] != null) {
          this.node.setAttribute(k, moreattrs[k].toString());
        } else {
          this.node.removeAttribute(k);
        }
      }
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function moves the current element pointer to the child,
   * unless text is provided.  If you need to add another child, it
   * is necessary to use up() to go back to the parent in the tree.
   *
   * @param {string} name - The name of the child.
   * @param {Object.<string, string>|string} [attrs] - The attributes of the child in object notation.
   * @param {string} [text] - The text to add to the child.
   *
   * @return {Builder} The Strophe.Builder object.
   */
  c(name, attrs, text) {
    const child = xmlElement(name, attrs, text);
    this.node.appendChild(child);
    if (typeof text !== "string" && typeof text !== "number") {
      this.node = child;
    }
    return this;
  }
  /**
   * Add a child to the current element and make it the new current
   * element.
   *
   * This function is the same as c() except that instead of using a
   * name and an attributes object to create the child it uses an
   * existing DOM element object.
   *
   * @param {Element} elem - A DOM element.
   * @return {Builder} The Strophe.Builder object.
   */
  cnode(elem) {
    let impNode;
    const xmlGen = xmlGenerator();
    try {
      impNode = xmlGen.importNode !== void 0;
    } catch (e) {
      impNode = false;
    }
    const newElem = impNode ? xmlGen.importNode(elem, true) : copyElement(elem);
    this.node.appendChild(newElem);
    this.node = /** @type {Element} */
    newElem;
    return this;
  }
  /**
   * Add a child text element.
   *
   * This *does not* make the child the new current element since there
   * are no children of text elements.
   *
   * @param {string} text - The text data to append to the current element.
   * @return {Builder} The Strophe.Builder object.
   */
  t(text) {
    const child = xmlTextNode(text);
    this.node.appendChild(child);
    return this;
  }
  /**
   * Replace current element contents with the HTML passed in.
   *
   * This *does not* make the child the new current element
   *
   * @param {string} html - The html to insert as contents of current element.
   * @return {Builder} The Strophe.Builder object.
   */
  h(html) {
    const fragment = xmlGenerator().createElement("body");
    fragment.innerHTML = html;
    const xhtml = createHtml(fragment);
    while (xhtml.childNodes.length > 0) {
      this.node.appendChild(xhtml.childNodes[0]);
    }
    return this;
  }
};
var builder_default = Builder;

// node_modules/strophe.js/src/request.js
var _requestId = 0;
var Request = class {
  /**
   * Create and initialize a new Request object.
   *
   * @param {Element} elem - The XML data to be sent in the request.
   * @param {Function} func - The function that will be called when the
   *     XMLHttpRequest readyState changes.
   * @param {number} rid - The BOSH rid attribute associated with this request.
   * @param {number} [sends=0] - The number of times this same request has been sent.
   */
  constructor(elem, func, rid, sends = 0) {
    this.id = ++_requestId;
    this.xmlData = elem;
    this.data = builder_default.serialize(elem);
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends;
    this.abort = false;
    this.dead = null;
    this.age = () => this.date ? ((/* @__PURE__ */ new Date()).valueOf() - this.date.valueOf()) / 1e3 : 0;
    this.timeDead = () => this.dead ? ((/* @__PURE__ */ new Date()).valueOf() - this.dead.valueOf()) / 1e3 : 0;
    this.xhr = this._newXHR();
  }
  /**
   * Get a response from the underlying XMLHttpRequest.
   * This function attempts to get a response from the request and checks
   * for errors.
   * @throws "parsererror" - A parser error occured.
   * @throws "bad-format" - The entity has sent XML that cannot be processed.
   * @return {Element} - The DOM element tree of the response.
   */
  getResponse() {
    var _a;
    let node = (_a = this.xhr.responseXML) == null ? void 0 : _a.documentElement;
    if (node) {
      if (node.tagName === "parsererror") {
        log_default.error("invalid response received");
        log_default.error("responseText: " + this.xhr.responseText);
        log_default.error("responseXML: " + builder_default.serialize(node));
        throw new Error("parsererror");
      }
    } else if (this.xhr.responseText) {
      log_default.debug("Got responseText but no responseXML; attempting to parse it with DOMParser...");
      node = new DOMParser().parseFromString(this.xhr.responseText, "application/xml").documentElement;
      const parserError = node == null ? void 0 : node.getElementsByTagName("parsererror").item(0);
      if (!node || parserError) {
        if (parserError) {
          log_default.error("invalid response received: " + parserError.textContent);
          log_default.error("responseText: " + this.xhr.responseText);
        }
        const error = new Error();
        error.name = ErrorCondition.BAD_FORMAT;
        throw error;
      }
    }
    return node;
  }
  /**
   * _Private_ helper function to create XMLHttpRequests.
   * This function creates XMLHttpRequests across all implementations.
   * @private
   * @return {XMLHttpRequest}
   */
  _newXHR() {
    const xhr = new XMLHttpRequest();
    if (xhr.overrideMimeType) {
      xhr.overrideMimeType("text/xml; charset=utf-8");
    }
    xhr.onreadystatechange = this.func.bind(null, this);
    return xhr;
  }
};
var request_default = Request;

// node_modules/strophe.js/src/bosh.js
var timeoutMultiplier = 1.1;
var secondaryTimeoutMultiplier = 0.1;
var Bosh = class _Bosh {
  /**
   * @param {Connection} connection - The Connection that will use BOSH.
   */
  constructor(connection) {
    this._conn = connection;
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.hold = 1;
    this.wait = 60;
    this.window = 5;
    this.errors = 0;
    this.inactivity = null;
    this.strip = _Bosh.prototype.strip ?? false;
    this.lastResponseHeaders = null;
    this._requests = [];
  }
  /**
   * @param {number} m
   */
  static setTimeoutMultiplier(m) {
    timeoutMultiplier = m;
  }
  /**
   * @returns {number}
   */
  static getTimeoutMultplier() {
    return timeoutMultiplier;
  }
  /**
   * @param {number} m
   */
  static setSecondaryTimeoutMultiplier(m) {
    secondaryTimeoutMultiplier = m;
  }
  /**
   * @returns {number}
   */
  static getSecondaryTimeoutMultplier() {
    return secondaryTimeoutMultiplier;
  }
  /**
   * _Private_ helper function to generate the <body/> wrapper for BOSH.
   * @private
   * @return {Builder} - A Builder with a <body/> element.
   */
  _buildBody() {
    const bodyWrap = $build("body", {
      "rid": this.rid++,
      "xmlns": NS.HTTPBIND
    });
    if (this.sid !== null) {
      bodyWrap.attrs({ "sid": this.sid });
    }
    if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
      this._cacheSession();
    }
    return bodyWrap;
  }
  /**
   * Reset the connection.
   * This function is called by the reset function of the Connection
   */
  _reset() {
    this.rid = Math.floor(Math.random() * 4294967295);
    this.sid = null;
    this.errors = 0;
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function that initializes the BOSH connection.
   * Creates and sends the Request that initializes the BOSH connection.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} route
   */
  _connect(wait, hold, route) {
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.errors = 0;
    const body = this._buildBody().attrs({
      "to": this._conn.domain,
      "xml:lang": "en",
      "wait": this.wait,
      "hold": this.hold,
      "content": "text/xml; charset=utf-8",
      "ver": "1.6",
      "xmpp:version": "1.0",
      "xmlns:xmpp": NS.BOSH
    });
    if (route) {
      body.attrs({ route });
    }
    const _connect_cb = this._conn._connect_cb;
    this._requests.push(
      new request_default(
        body.tree(),
        this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string} jid - The full JID that is bound by the session.
   * @param {string} sid - The SID of the BOSH session.
   * @param {number} rid - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _attach(jid, sid, rid, callback, wait, hold, wind) {
    this._conn.jid = jid;
    this.sid = sid;
    this.rid = rid;
    this._conn.connect_callback = callback;
    this._conn.domain = getDomainFromJid(this._conn.jid);
    this._conn.authenticated = true;
    this._conn.connected = true;
    this.wait = wait || this.wait;
    this.hold = hold || this.hold;
    this.window = wind || this.window;
    this._conn._changeConnectStatus(Status.ATTACHED, null);
  }
  /**
   * Attempt to restore a cached BOSH session
   *
   * @param {string} jid - The full JID that is bound by the session.
   *     This parameter is optional but recommended, specifically in cases
   *     where prebinded BOSH sessions are used where it's important to know
   *     that the right session is being restored.
   * @param {Function} callback The connect callback function.
   * @param {number} wait - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} hold - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} wind - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  _restore(jid, callback, wait, hold, wind) {
    const session = JSON.parse(sessionStorage.getItem("strophe-bosh-session"));
    if (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || getBareJidFromJid(session.jid) === getBareJidFromJid(jid) || // If authcid is null, then it's an anonymous login, so
    // we compare only the domains:
    getNodeFromJid(jid) === null && getDomainFromJid(session.jid) === jid)) {
      this._conn.restored = true;
      this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
    } else {
      const error = new Error("_restore: no restoreable session.");
      error.name = "StropheSessionError";
      throw error;
    }
  }
  /**
   * _Private_ handler for the beforeunload event.
   * This handler is used to process the Bosh-part of the initial request.
   * @private
   */
  _cacheSession() {
    if (this._conn.authenticated) {
      if (this._conn.jid && this.rid && this.sid) {
        sessionStorage.setItem(
          "strophe-bosh-session",
          JSON.stringify({
            "jid": this._conn.jid,
            "rid": this.rid,
            "sid": this.sid
          })
        );
      }
    } else {
      sessionStorage.removeItem("strophe-bosh-session");
    }
  }
  /**
   * _Private_ handler for initial connection request.
   * This handler is used to process the Bosh-part of the initial request.
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const typ = bodyWrap.getAttribute("type");
    if (typ !== null && typ === "terminate") {
      let cond = bodyWrap.getAttribute("condition");
      log_default.error("BOSH-Connection failed: " + cond);
      const conflict = bodyWrap.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._conn._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "unknown");
      }
      this._conn._doDisconnect(cond);
      return Status.CONNFAIL;
    }
    if (!this.sid) {
      this.sid = bodyWrap.getAttribute("sid");
    }
    const wind = bodyWrap.getAttribute("requests");
    if (wind) {
      this.window = parseInt(wind, 10);
    }
    const hold = bodyWrap.getAttribute("hold");
    if (hold) {
      this.hold = parseInt(hold, 10);
    }
    const wait = bodyWrap.getAttribute("wait");
    if (wait) {
      this.wait = parseInt(wait, 10);
    }
    const inactivity = bodyWrap.getAttribute("inactivity");
    if (inactivity) {
      this.inactivity = parseInt(inactivity, 10);
    }
  }
  /**
   * _Private_ part of Connection.disconnect for Bosh
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    this._sendTerminate(pres);
  }
  /**
   * _Private_ function to disconnect.
   * Resets the SID and RID.
   */
  _doDisconnect() {
    this.sid = null;
    this.rid = Math.floor(Math.random() * 4294967295);
    if (this._conn._sessionCachingSupported()) {
      sessionStorage.removeItem("strophe-bosh-session");
    }
    this._conn.nextValidRid(this.rid);
  }
  /**
   * _Private_ function to check if the Request queue is empty.
   * @return {boolean} - True, if there are no Requests queued, False otherwise.
   */
  _emptyQueue() {
    return this._requests.length === 0;
  }
  /**
   * _Private_ function to call error handlers registered for HTTP errors.
   * @private
   * @param {Request} req - The request that is changing readyState.
   */
  _callProtocolErrorHandlers(req) {
    const reqStatus = _Bosh._getRequestStatus(req);
    const err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
    if (err_callback) {
      err_callback.call(this, reqStatus);
    }
  }
  /**
   * _Private_ function to handle the error count.
   *
   * Requests are resent automatically until their error count reaches
   * 5.  Each time an error is encountered, this function is called to
   * increment the count and disconnect if the count is too high.
   * @private
   * @param {number} reqStatus - The request status.
   */
  _hitError(reqStatus) {
    this.errors++;
    log_default.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
    if (this.errors > 4) {
      this._conn._onDisconnectTimeout();
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received and sends a blank poll request.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log_default.warn(
      "Server did not yet offer a supported authentication mechanism. Sending a blank poll request."
    );
    if (callback) {
      callback = callback.bind(this._conn);
    } else {
      callback = this._conn._connect_cb.bind(this._conn);
    }
    const body = this._buildBody();
    this._requests.push(
      new request_default(
        body.tree(),
        this._onRequestStateChange.bind(this, callback),
        Number(body.tree().getAttribute("rid"))
      )
    );
    this._throttledRequestHandler();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   * Cancels all remaining Requests and clears the queue.
   */
  _onDisconnectTimeout() {
    this._abortAllRequests();
  }
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
    while (this._requests.length > 0) {
      const req = this._requests.pop();
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
    }
  }
  /**
   * _Private_ handler called by {@link Connection#_onIdle|Connection._onIdle()}.
   * Sends all queued Requests or polls with empty Request if there are none.
   */
  _onIdle() {
    const data = this._conn._data;
    if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
      log_default.debug("no requests during idle cycle, sending blank request");
      data.push(null);
    }
    if (this._conn.paused) {
      return;
    }
    if (this._requests.length < 2 && data.length > 0) {
      const body = this._buildBody();
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          if (data[i] === "restart") {
            body.attrs({
              "to": this._conn.domain,
              "xml:lang": "en",
              "xmpp:restart": "true",
              "xmlns:xmpp": NS.BOSH
            });
          } else {
            body.cnode(
              /** @type {Element} */
              data[i]
            ).up();
          }
        }
      }
      delete this._conn._data;
      this._conn._data = [];
      this._requests.push(
        new request_default(
          body.tree(),
          this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
          Number(body.tree().getAttribute("rid"))
        )
      );
      this._throttledRequestHandler();
    }
    if (this._requests.length > 0) {
      const time_elapsed = this._requests[0].age();
      if (this._requests[0].dead !== null) {
        if (this._requests[0].timeDead() > Math.floor(timeoutMultiplier * this.wait)) {
          this._throttledRequestHandler();
        }
      }
      if (time_elapsed > Math.floor(timeoutMultiplier * this.wait)) {
        log_default.warn(
          "Request " + this._requests[0].id + " timed out, over " + Math.floor(timeoutMultiplier * this.wait) + " seconds since last activity"
        );
        this._throttledRequestHandler();
      }
    }
  }
  /**
   * Returns the HTTP status code from a {@link Request}
   * @private
   * @param {Request} req - The {@link Request} instance.
   * @param {number} [def] - The default value that should be returned if no status value was found.
   */
  static _getRequestStatus(req, def) {
    let reqStatus;
    if (req.xhr.readyState === 4) {
      try {
        reqStatus = req.xhr.status;
      } catch (e) {
        log_default.error("Caught an error while retrieving a request's status, reqStatus: " + reqStatus);
      }
    }
    if (typeof reqStatus === "undefined") {
      reqStatus = typeof def === "number" ? def : 0;
    }
    return reqStatus;
  }
  /**
   * _Private_ handler for {@link Request} state changes.
   *
   * This function is called when the XMLHttpRequest readyState changes.
   * It contains a lot of error handling logic for the many ways that
   * requests can fail, and calls the request callback when requests
   * succeed.
   * @private
   *
   * @param {Function} func - The handler for the request.
   * @param {Request} req - The request that is changing readyState.
   */
  _onRequestStateChange(func, req) {
    log_default.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
    if (req.abort) {
      req.abort = false;
      return;
    }
    if (req.xhr.readyState !== 4) {
      return;
    }
    const reqStatus = _Bosh._getRequestStatus(req);
    this.lastResponseHeaders = req.xhr.getAllResponseHeaders();
    if (this._conn.disconnecting && reqStatus >= 400) {
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      return;
    }
    const reqIs0 = this._requests[0] === req;
    const reqIs1 = this._requests[1] === req;
    const valid_request = reqStatus > 0 && reqStatus < 500;
    const too_many_retries = req.sends > this._conn.maxRetries;
    if (valid_request || too_many_retries) {
      this._removeRequest(req);
      log_default.debug("request id " + req.id + " should now be removed");
    }
    if (reqStatus === 200) {
      if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(timeoutMultiplier * this.wait)) {
        this._restartRequest(0);
      }
      this._conn.nextValidRid(req.rid + 1);
      log_default.debug("request id " + req.id + "." + req.sends + " got 200");
      func(req);
      this.errors = 0;
    } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12e3) {
      log_default.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
      this._hitError(reqStatus);
      this._callProtocolErrorHandlers(req);
      if (reqStatus >= 400 && reqStatus < 500) {
        this._conn._changeConnectStatus(Status.DISCONNECTING, null);
        this._conn._doDisconnect();
      }
    } else {
      log_default.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
    }
    if (!valid_request && !too_many_retries) {
      this._throttledRequestHandler();
    } else if (too_many_retries && !this._conn.connected) {
      this._conn._changeConnectStatus(Status.CONNFAIL, "giving-up");
    }
  }
  /**
   * _Private_ function to process a request in the queue.
   *
   * This function takes requests off the queue and sends them and
   * restarts dead requests.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _processRequest(i) {
    var _a, _b, _c, _d, _e, _f;
    let req = this._requests[i];
    const reqStatus = _Bosh._getRequestStatus(req, -1);
    if (req.sends > this._conn.maxRetries) {
      this._conn._onDisconnectTimeout();
      return;
    }
    const time_elapsed = req.age();
    const primary_timeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(timeoutMultiplier * this.wait);
    const secondary_timeout = req.dead !== null && req.timeDead() > Math.floor(secondaryTimeoutMultiplier * this.wait);
    const server_error = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);
    if (primary_timeout || secondary_timeout || server_error) {
      if (secondary_timeout) {
        log_default.error(`Request ${this._requests[i].id} timed out (secondary), restarting`);
      }
      req.abort = true;
      req.xhr.abort();
      req.xhr.onreadystatechange = function() {
      };
      this._requests[i] = new request_default(req.xmlData, req.origFunc, req.rid, req.sends);
      req = this._requests[i];
    }
    if (req.xhr.readyState === 0) {
      log_default.debug("request id " + req.id + "." + req.sends + " posting");
      try {
        const content_type = this._conn.options.contentType || "text/xml; charset=utf-8";
        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
        if (typeof req.xhr.setRequestHeader !== "undefined") {
          req.xhr.setRequestHeader("Content-Type", content_type);
        }
        if (this._conn.options.withCredentials) {
          req.xhr.withCredentials = true;
        }
      } catch (e2) {
        log_default.error("XHR open failed: " + e2.toString());
        if (!this._conn.connected) {
          this._conn._changeConnectStatus(Status.CONNFAIL, "bad-service");
        }
        this._conn.disconnect();
        return;
      }
      const sendFunc = () => {
        req.date = (/* @__PURE__ */ new Date()).valueOf();
        if (this._conn.options.customHeaders) {
          const headers = this._conn.options.customHeaders;
          for (const header in headers) {
            if (Object.prototype.hasOwnProperty.call(headers, header)) {
              req.xhr.setRequestHeader(header, headers[header]);
            }
          }
        }
        req.xhr.send(req.data);
      };
      if (req.sends > 1) {
        const backoff = Math.min(Math.floor(timeoutMultiplier * this.wait), Math.pow(req.sends, 3)) * 1e3;
        setTimeout(function() {
          sendFunc();
        }, backoff);
      } else {
        sendFunc();
      }
      req.sends++;
      if (this.strip && req.xmlData.nodeName === "body" && req.xmlData.childNodes.length) {
        (_b = (_a = this._conn).xmlOutput) == null ? void 0 : _b.call(_a, req.xmlData.children[0]);
      } else {
        (_d = (_c = this._conn).xmlOutput) == null ? void 0 : _d.call(_c, req.xmlData);
      }
      (_f = (_e = this._conn).rawOutput) == null ? void 0 : _f.call(_e, req.data);
    } else {
      log_default.debug(
        "_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState
      );
    }
  }
  /**
   * _Private_ function to remove a request from the queue.
   * @private
   * @param {Request} req - The request to remove.
   */
  _removeRequest(req) {
    log_default.debug("removing request");
    for (let i = this._requests.length - 1; i >= 0; i--) {
      if (req === this._requests[i]) {
        this._requests.splice(i, 1);
      }
    }
    req.xhr.onreadystatechange = function() {
    };
    this._throttledRequestHandler();
  }
  /**
   * _Private_ function to restart a request that is presumed dead.
   * @private
   *
   * @param {number} i - The index of the request in the queue.
   */
  _restartRequest(i) {
    const req = this._requests[i];
    if (req.dead === null) {
      req.dead = /* @__PURE__ */ new Date();
    }
    this._processRequest(i);
  }
  /**
   * _Private_ function to get a stanza out of a request.
   * Tries to extract a stanza out of a Request Object.
   * When this fails the current connection will be disconnected.
   *
   * @param {Request} req - The Request.
   * @return {Element} - The stanza that was passed.
   */
  _reqToData(req) {
    try {
      return req.getResponse();
    } catch (e) {
      if (e.message !== "parsererror") {
        throw e;
      }
      this._conn.disconnect("strophe-parsererror");
    }
  }
  /**
   * _Private_ function to send initial disconnect sequence.
   *
   * This is the first step in a graceful disconnect.  It sends
   * the BOSH server a terminate body and includes an unavailable
   * presence if authentication has completed.
   * @private
   * @param {Element|Builder} [pres]
   */
  _sendTerminate(pres) {
    log_default.debug("_sendTerminate was called");
    const body = this._buildBody().attrs({ type: "terminate" });
    const el = pres instanceof builder_default ? pres.tree() : pres;
    if (pres) {
      body.cnode(el);
    }
    const req = new request_default(
      body.tree(),
      this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),
      Number(body.tree().getAttribute("rid"))
    );
    this._requests.push(req);
    this._throttledRequestHandler();
  }
  /**
   * _Private_ part of the Connection.send function for BOSH
   * Just triggers the RequestHandler to send the messages that are in the queue
   */
  _send() {
    clearTimeout(this._conn._idleTimeout);
    this._throttledRequestHandler();
    this._conn._idleTimeout = setTimeout(() => this._conn._onIdle(), 100);
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    this._throttledRequestHandler();
    clearTimeout(this._conn._idleTimeout);
  }
  /**
   * _Private_ function to throttle requests to the connection window.
   *
   * This function makes sure we don't send requests so fast that the
   * request ids overflow the connection window in the case that one
   * request died.
   * @private
   */
  _throttledRequestHandler() {
    if (!this._requests) {
      log_default.debug("_throttledRequestHandler called with undefined requests");
    } else {
      log_default.debug("_throttledRequestHandler called with " + this._requests.length + " requests");
    }
    if (!this._requests || this._requests.length === 0) {
      return;
    }
    if (this._requests.length > 0) {
      this._processRequest(0);
    }
    if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
      this._processRequest(1);
    }
  }
};
var bosh_default = Bosh;

// node_modules/strophe.js/src/connection.js
var import_abab = __toESM(require_abab());

// node_modules/strophe.js/src/handler.js
var Handler = class {
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Create and initialize a new Handler.
   *
   * @param {Function} handler - A function to be executed when the handler is run.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The element name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The element id attribute to match.
   * @param {string} [from] - The element from attribute to match.
   * @param {HandlerOptions} [options] - Handler options
   */
  constructor(handler, ns, name, type, id, from, options) {
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || { "matchBareFromJid": false, "ignoreNamespaceFragment": false };
    if (this.options.matchBareFromJid) {
      this.from = from ? getBareJidFromJid(from) : null;
    } else {
      this.from = from;
    }
    this.user = true;
  }
  /**
   * Returns the XML namespace attribute on an element.
   * If `ignoreNamespaceFragment` was passed in for this handler, then the
   * URL fragment will be stripped.
   * @param {Element} elem - The XML element with the namespace.
   * @return {string} - The namespace, with optionally the fragment stripped.
   */
  getNamespace(elem) {
    let elNamespace = elem.getAttribute("xmlns");
    if (elNamespace && this.options.ignoreNamespaceFragment) {
      elNamespace = elNamespace.split("#")[0];
    }
    return elNamespace;
  }
  /**
   * Tests if a stanza matches the namespace set for this Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  namespaceMatch(elem) {
    let nsMatch = false;
    if (!this.ns) {
      return true;
    } else {
      forEachChild(
        elem,
        null,
        /** @param {Element} elem */
        (elem2) => {
          if (this.getNamespace(elem2) === this.ns) {
            nsMatch = true;
          }
        }
      );
      return nsMatch || this.getNamespace(elem) === this.ns;
    }
  }
  /**
   * Tests if a stanza matches the Handler.
   * @param {Element} elem - The XML element to test.
   * @return {boolean} - true if the stanza matches and false otherwise.
   */
  isMatch(elem) {
    let from = elem.getAttribute("from");
    if (this.options.matchBareFromJid) {
      from = getBareJidFromJid(from);
    }
    const elem_type = elem.getAttribute("type");
    if (this.namespaceMatch(elem) && (!this.name || isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute("id") === this.id) && (!this.from || from === this.from)) {
      return true;
    }
    return false;
  }
  /**
   * Run the callback on a matching stanza.
   * @param {Element} elem - The DOM element that triggered the Handler.
   * @return {boolean} - A boolean indicating if the handler should remain active.
   */
  run(elem) {
    let result = null;
    try {
      result = this.handler(elem);
    } catch (e) {
      handleError(e);
      throw e;
    }
    return result;
  }
  /**
   * Get a String representation of the Handler object.
   * @return {string}
   */
  toString() {
    return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}";
  }
};
var handler_default = Handler;

// node_modules/strophe.js/src/timed-handler.js
var TimedHandler = class {
  /**
   * Create and initialize a new Strophe.TimedHandler object.
   * @param {number} period - The number of milliseconds to wait before the
   *     handler is called.
   * @param {Function} handler - The callback to run when the handler fires.  This
   *     function should take no arguments.
   */
  constructor(period, handler) {
    this.period = period;
    this.handler = handler;
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    this.user = true;
  }
  /**
   * Run the callback for the Strophe.TimedHandler.
   *
   * @return {boolean} Returns the result of running the handler,
   *  which is `true` if the Strophe.TimedHandler should be called again,
   *  and `false` otherwise.
   */
  run() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
    return this.handler();
  }
  /**
   * Reset the last called time for the Strophe.TimedHandler.
   */
  reset() {
    this.lastCalled = (/* @__PURE__ */ new Date()).getTime();
  }
  /**
   * Get a string representation of the Strophe.TimedHandler object.
   * @return {string}
   */
  toString() {
    return "{TimedHandler: " + this.handler + "(" + this.period + ")}";
  }
};
var timed_handler_default = TimedHandler;

// node_modules/strophe.js/src/sasl.js
var SASLMechanism = class {
  /**
   * PrivateConstructor: Strophe.SASLMechanism
   * SASL auth mechanism abstraction.
   * @param {String} [name] - SASL Mechanism name.
   * @param {Boolean} [isClientFirst] - If client should send response first without challenge.
   * @param {Number} [priority] - Priority.
   */
  constructor(name, isClientFirst, priority) {
    this.mechname = name;
    this.isClientFirst = isClientFirst;
    this.priority = priority;
  }
  /**
   * Checks if mechanism able to run.
   * To disable a mechanism, make this return false;
   *
   * To disable plain authentication run
   * > Strophe.SASLPlain.test = function() {
   * >   return false;
   * > }
   *
   * See <SASL mechanisms> for a list of available mechanisms.
   * @param {Connection} connection - Target Connection.
   * @return {boolean} If mechanism was able to run.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  test(connection) {
    return true;
  }
  /**
   * Called before starting mechanism on some connection.
   * @param {Connection} connection - Target Connection.
   */
  onStart(connection) {
    this._connection = connection;
  }
  /**
   * Called by protocol implementation on incoming challenge.
   *
   * By deafult, if the client is expected to send data first (isClientFirst === true),
   * this method is called with `challenge` as null on the first call,
   * unless `clientChallenge` is overridden in the relevant subclass.
   * @param {Connection} connection - Target Connection.
   * @param {string} [challenge] - current challenge to handle.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  onChallenge(connection, challenge) {
    throw new Error("You should implement challenge handling!");
  }
  /**
   * Called by the protocol implementation if the client is expected to send
   * data first in the authentication exchange (i.e. isClientFirst === true).
   * @param {Connection} connection - Target Connection.
   * @return {string|Promise<string|false>} Mechanism response.
   */
  clientChallenge(connection) {
    if (!this.isClientFirst) {
      throw new Error("clientChallenge should not be called if isClientFirst is false!");
    }
    return this.onChallenge(connection);
  }
  /**
   * Protocol informs mechanism implementation about SASL failure.
   */
  onFailure() {
    this._connection = null;
  }
  /**
   * Protocol informs mechanism implementation about SASL success.
   */
  onSuccess() {
    this._connection = null;
  }
};
var sasl_default = SASLMechanism;

// node_modules/strophe.js/src/sasl-anon.js
var SASLAnonymous = class extends sasl_default {
  /**
   * SASL ANONYMOUS authentication.
   */
  constructor(mechname = "ANONYMOUS", isClientFirst = false, priority = 20) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid === null;
  }
};
var sasl_anon_default = SASLAnonymous;

// node_modules/strophe.js/src/sasl-external.js
var SASLExternal = class extends sasl_default {
  /**
   * SASL EXTERNAL authentication.
   *
   * The EXTERNAL mechanism allows a client to request the server to use
   * credentials established by means external to the mechanism to
   * authenticate the client. The external means may be, for instance,
   * TLS services.
   */
  constructor(mechname = "EXTERNAL", isClientFirst = true, priority = 10) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    return connection.authcid === connection.authzid ? "" : connection.authzid;
  }
};
var sasl_external_default = SASLExternal;

// node_modules/strophe.js/src/sasl-oauthbearer.js
var SASLOAuthBearer = class extends sasl_default {
  /**
   * SASL OAuth Bearer authentication.
   */
  constructor(mechname = "OAUTHBEARER", isClientFirst = true, priority = 40) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "n,";
    if (connection.authcid !== null) {
      auth_str = auth_str + "a=" + connection.authzid;
    }
    auth_str = auth_str + ",";
    auth_str = auth_str + "";
    auth_str = auth_str + "auth=Bearer ";
    auth_str = auth_str + connection.pass;
    auth_str = auth_str + "";
    auth_str = auth_str + "";
    return utils.utf16to8(auth_str);
  }
};
var sasl_oauthbearer_default = SASLOAuthBearer;

// node_modules/strophe.js/src/sasl-plain.js
var SASLPlain = class extends sasl_default {
  /**
   * SASL PLAIN authentication.
   */
  constructor(mechname = "PLAIN", isClientFirst = true, priority = 50) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    const { authcid, authzid, domain, pass } = connection;
    if (!domain) {
      throw new Error("SASLPlain onChallenge: domain is not defined!");
    }
    let auth_str = authzid !== `${authcid}@${domain}` ? authzid : "";
    auth_str = auth_str + "\0";
    auth_str = auth_str + authcid;
    auth_str = auth_str + "\0";
    auth_str = auth_str + pass;
    return utils.utf16to8(auth_str);
  }
};
var sasl_plain_default = SASLPlain;

// node_modules/strophe.js/src/scram.js
async function scramClientProof(authMessage, clientKey, hashName) {
  const storedKey = await crypto.subtle.importKey(
    "raw",
    await crypto.subtle.digest(hashName, clientKey),
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  const clientSignature = await crypto.subtle.sign("HMAC", storedKey, utils.stringToArrayBuf(authMessage));
  return utils.xorArrayBuffers(clientKey, clientSignature);
}
function scramParseChallenge(challenge) {
  let nonce, salt, iter;
  const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
  while (challenge.match(attribMatch)) {
    const matches = challenge.match(attribMatch);
    challenge = challenge.replace(matches[0], "");
    switch (matches[1]) {
      case "r":
        nonce = matches[2];
        break;
      case "s":
        salt = utils.base64ToArrayBuf(matches[2]);
        break;
      case "i":
        iter = parseInt(matches[2], 10);
        break;
      case "m":
        return void 0;
      default:
        break;
    }
  }
  if (isNaN(iter) || iter < 4096) {
    log_default.warn("Failing SCRAM authentication because server supplied iteration count < 4096.");
    return void 0;
  }
  if (!salt) {
    log_default.warn("Failing SCRAM authentication because server supplied incorrect salt.");
    return void 0;
  }
  return { "nonce": nonce, "salt": salt, "iter": iter };
}
async function scramDeriveKeys(password, salt, iter, hashName, hashBits) {
  const saltedPasswordBits = await crypto.subtle.deriveBits(
    { "name": "PBKDF2", "salt": salt, "iterations": iter, "hash": { "name": hashName } },
    await crypto.subtle.importKey("raw", utils.stringToArrayBuf(password), "PBKDF2", false, ["deriveBits"]),
    hashBits
  );
  const saltedPassword = await crypto.subtle.importKey(
    "raw",
    saltedPasswordBits,
    { "name": "HMAC", "hash": hashName },
    false,
    ["sign"]
  );
  return {
    "ck": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Client Key")),
    "sk": await crypto.subtle.sign("HMAC", saltedPassword, utils.stringToArrayBuf("Server Key"))
  };
}
async function scramServerSign(authMessage, sk, hashName) {
  const serverKey = await crypto.subtle.importKey("raw", sk, { "name": "HMAC", "hash": hashName }, false, ["sign"]);
  return crypto.subtle.sign("HMAC", serverKey, utils.stringToArrayBuf(authMessage));
}
function generate_cnonce() {
  const bytes = new Uint8Array(16);
  return utils.arrayBufToBase64(crypto.getRandomValues(bytes).buffer);
}
var scram = {
  /**
   * On success, sets
   * connection_sasl_data["server-signature"]
   * and
   * connection._sasl_data.keys
   *
   * The server signature should be verified after this function completes..
   *
   * On failure, returns connection._sasl_failure_cb();
   * @param {Connection} connection
   * @param {string} challenge
   * @param {string} hashName
   * @param {number} hashBits
   */
  async scramResponse(connection, challenge, hashName, hashBits) {
    const cnonce = connection._sasl_data.cnonce;
    const challengeData = scramParseChallenge(challenge);
    if (!challengeData && (challengeData == null ? void 0 : challengeData.nonce.slice(0, cnonce.length)) !== cnonce) {
      log_default.warn("Failing SCRAM authentication because server supplied incorrect nonce.");
      connection._sasl_data = {};
      return connection._sasl_failure_cb();
    }
    let clientKey, serverKey;
    const { pass } = connection;
    if (typeof connection.pass === "string" || connection.pass instanceof String) {
      const keys = await scramDeriveKeys(
        /** @type {string} */
        pass,
        challengeData.salt,
        challengeData.iter,
        hashName,
        hashBits
      );
      clientKey = keys.ck;
      serverKey = keys.sk;
    } else if (
      // Either restore the client key and server key passed in, or derive new ones
      /** @type {Password} */
      (pass == null ? void 0 : pass.name) === hashName && /** @type {Password} */
      (pass == null ? void 0 : pass.salt) === utils.arrayBufToBase64(challengeData.salt) && /** @type {Password} */
      (pass == null ? void 0 : pass.iter) === challengeData.iter
    ) {
      const { ck, sk } = (
        /** @type {Password} */
        pass
      );
      clientKey = utils.base64ToArrayBuf(ck);
      serverKey = utils.base64ToArrayBuf(sk);
    } else {
      return connection._sasl_failure_cb();
    }
    const clientFirstMessageBare = connection._sasl_data["client-first-message-bare"];
    const serverFirstMessage = challenge;
    const clientFinalMessageBare = `c=biws,r=${challengeData.nonce}`;
    const authMessage = `${clientFirstMessageBare},${serverFirstMessage},${clientFinalMessageBare}`;
    const clientProof = await scramClientProof(authMessage, clientKey, hashName);
    const serverSignature = await scramServerSign(authMessage, serverKey, hashName);
    connection._sasl_data["server-signature"] = utils.arrayBufToBase64(serverSignature);
    connection._sasl_data.keys = {
      "name": hashName,
      "iter": challengeData.iter,
      "salt": utils.arrayBufToBase64(challengeData.salt),
      "ck": utils.arrayBufToBase64(clientKey),
      "sk": utils.arrayBufToBase64(serverKey)
    };
    return `${clientFinalMessageBare},p=${utils.arrayBufToBase64(clientProof)}`;
  },
  /**
   * Returns a string containing the client first message
   * @param {Connection} connection
   * @param {string} test_cnonce
   */
  clientChallenge(connection, test_cnonce) {
    const cnonce = test_cnonce || generate_cnonce();
    const client_first_message_bare = `n=${connection.authcid},r=${cnonce}`;
    connection._sasl_data.cnonce = cnonce;
    connection._sasl_data["client-first-message-bare"] = client_first_message_bare;
    return `n,,${client_first_message_bare}`;
  }
};

// node_modules/strophe.js/src/sasl-sha1.js
var SASLSHA1 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 1 authentication.
   */
  constructor(mechname = "SCRAM-SHA-1", isClientFirst = true, priority = 60) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   * @return {Promise<string|false>} Mechanism response.
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-1", 160);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha1_default = SASLSHA1;

// node_modules/strophe.js/src/sasl-sha256.js
var SASLSHA256 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 256 authentication.
   */
  constructor(mechname = "SCRAM-SHA-256", isClientFirst = true, priority = 70) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-256", 256);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha256_default = SASLSHA256;

// node_modules/strophe.js/src/sasl-sha384.js
var SASLSHA384 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 384 authentication.
   */
  constructor(mechname = "SCRAM-SHA-384", isClientFirst = true, priority = 71) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-384", 384);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha384_default = SASLSHA384;

// node_modules/strophe.js/src/sasl-sha512.js
var SASLSHA512 = class extends sasl_default {
  /**
   * SASL SCRAM SHA 512 authentication.
   */
  constructor(mechname = "SCRAM-SHA-512", isClientFirst = true, priority = 72) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.authcid !== null;
  }
  /**
   * @param {Connection} connection
   * @param {string} [challenge]
   */
  // eslint-disable-next-line class-methods-use-this
  async onChallenge(connection, challenge) {
    return await scram.scramResponse(connection, challenge, "SHA-512", 512);
  }
  /**
   * @param {Connection} connection
   * @param {string} [test_cnonce]
   */
  // eslint-disable-next-line class-methods-use-this
  clientChallenge(connection, test_cnonce) {
    return scram.clientChallenge(connection, test_cnonce);
  }
};
var sasl_sha512_default = SASLSHA512;

// node_modules/strophe.js/src/sasl-xoauth2.js
var SASLXOAuth2 = class extends sasl_default {
  /**
   * SASL X-OAuth2 authentication.
   */
  constructor(mechname = "X-OAUTH2", isClientFirst = true, priority = 30) {
    super(mechname, isClientFirst, priority);
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  test(connection) {
    return connection.pass !== null;
  }
  /**
   * @param {Connection} connection
   */
  // eslint-disable-next-line class-methods-use-this
  onChallenge(connection) {
    let auth_str = "\0";
    if (connection.authcid !== null) {
      auth_str = auth_str + connection.authzid;
    }
    auth_str = auth_str + "\0";
    auth_str = auth_str + connection.pass;
    return utils.utf16to8(auth_str);
  }
};
var sasl_xoauth2_default = SASLXOAuth2;

// node_modules/strophe.js/src/errors.js
var SessionError = class extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "StropheSessionError";
  }
};

// node_modules/strophe.js/src/websocket.js
var Websocket = class {
  /**
   * Create and initialize a WebSocket object.
   * Currently only sets the connection Object.
   * @param {Connection} connection - The Connection that will use WebSockets.
   */
  constructor(connection) {
    this._conn = connection;
    this.strip = "wrapper";
    const service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
      let new_service = "";
      if (connection.options.protocol === "ws" && location.protocol !== "https:") {
        new_service += "ws";
      } else {
        new_service += "wss";
      }
      new_service += "://" + location.host;
      if (service.indexOf("/") !== 0) {
        new_service += location.pathname + service;
      } else {
        new_service += service;
      }
      connection.service = new_service;
    }
  }
  /**
   * _Private_ helper function to generate the <stream> start tag for WebSockets
   * @private
   * @return {Builder} - A Builder with a <stream> element.
   */
  _buildStream() {
    return $build("open", {
      "xmlns": NS.FRAMING,
      "to": this._conn.domain,
      "version": "1.0"
    });
  }
  /**
   * _Private_ checks a message for stream:error
   * @private
   * @param {Element} bodyWrap - The received stanza.
   * @param {number} connectstatus - The ConnectStatus that will be set on error.
   * @return {boolean} - true if there was a streamerror, false otherwise.
   */
  _checkStreamError(bodyWrap, connectstatus) {
    let errors;
    if (bodyWrap.getElementsByTagNameNS) {
      errors = bodyWrap.getElementsByTagNameNS(NS.STREAM, "error");
    } else {
      errors = bodyWrap.getElementsByTagName("stream:error");
    }
    if (errors.length === 0) {
      return false;
    }
    const error = errors[0];
    let condition = "";
    let text = "";
    const ns = "urn:ietf:params:xml:ns:xmpp-streams";
    for (let i = 0; i < error.childNodes.length; i++) {
      const e = error.childNodes[i];
      if (e.nodeType === e.ELEMENT_NODE) {
        const el = (
          /** @type {any} */
          e
        );
        if (el.getAttribute("xmlns") !== ns) {
          break;
        }
      }
      if (e.nodeName === "text") {
        text = e.textContent;
      } else {
        condition = e.nodeName;
      }
    }
    let errorString = "WebSocket stream error: ";
    if (condition) {
      errorString += condition;
    } else {
      errorString += "unknown";
    }
    if (text) {
      errorString += " - " + text;
    }
    log_default.error(errorString);
    this._conn._changeConnectStatus(connectstatus, condition);
    this._conn._doDisconnect();
    return true;
  }
  /**
   * Reset the connection.
   *
   * This function is called by the reset function of the Strophe Connection.
   * Is not needed by WebSockets.
   */
  // eslint-disable-next-line class-methods-use-this
  _reset() {
    return;
  }
  /**
   * _Private_ function called by Connection.connect
   *
   * Creates a WebSocket for a connection and assigns Callbacks to it.
   * Does nothing if there already is a WebSocket.
   */
  _connect() {
    this._closeSocket();
    this.socket = new WebSocket(this._conn.service, "xmpp");
    this.socket.onopen = () => this._onOpen();
    this.socket.onerror = (e) => this._onError(e);
    this.socket.onclose = (e) => this._onClose(e);
    this.socket.onmessage = (message) => this._onInitialMessage(message);
  }
  /**
   * _Private_ function called by Connection._connect_cb
   * checks for stream:error
   * @param {Element} bodyWrap - The received stanza.
   */
  _connect_cb(bodyWrap) {
    const error = this._checkStreamError(bodyWrap, Status.CONNFAIL);
    if (error) {
      return Status.CONNFAIL;
    }
  }
  /**
   * _Private_ function that checks the opening <open /> tag for errors.
   *
   * Disconnects if there is an error and returns false, true otherwise.
   * @private
   * @param {Element} message - Stanza containing the <open /> tag.
   */
  _handleStreamStart(message) {
    let error = null;
    const ns = message.getAttribute("xmlns");
    if (typeof ns !== "string") {
      error = "Missing xmlns in <open />";
    } else if (ns !== NS.FRAMING) {
      error = "Wrong xmlns in <open />: " + ns;
    }
    const ver = message.getAttribute("version");
    if (typeof ver !== "string") {
      error = "Missing version in <open />";
    } else if (ver !== "1.0") {
      error = "Wrong version in <open />: " + ver;
    }
    if (error) {
      this._conn._changeConnectStatus(Status.CONNFAIL, error);
      this._conn._doDisconnect();
      return false;
    }
    return true;
  }
  /**
   * _Private_ function that handles the first connection messages.
   *
   * On receiving an opening stream tag this callback replaces itself with the real
   * message handler. On receiving a stream error the connection is terminated.
   * @param {MessageEvent} message
   */
  _onInitialMessage(message) {
    if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
      const data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
      if (data === "") return;
      const streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
      this._conn.xmlInput(streamStart);
      this._conn.rawInput(message.data);
      if (this._handleStreamStart(streamStart)) {
        this._connect_cb(streamStart);
      }
    } else if (message.data.indexOf("<close ") === 0) {
      const parsedMessage = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
      this._conn.xmlInput(parsedMessage);
      this._conn.rawInput(message.data);
      const see_uri = parsedMessage.getAttribute("see-other-uri");
      if (see_uri) {
        const service = this._conn.service;
        const isSecureRedirect = service.indexOf("wss:") >= 0 && see_uri.indexOf("wss:") >= 0 || service.indexOf("ws:") >= 0;
        if (isSecureRedirect) {
          this._conn._changeConnectStatus(
            Status.REDIRECT,
            "Received see-other-uri, resetting connection"
          );
          this._conn.reset();
          this._conn.service = see_uri;
          this._connect();
        }
      } else {
        this._conn._changeConnectStatus(Status.CONNFAIL, "Received closing stream");
        this._conn._doDisconnect();
      }
    } else {
      this._replaceMessageHandler();
      const string = this._streamWrap(message.data);
      const elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
      this._conn._connect_cb(elem, null, message.data);
    }
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this.socket.onmessage = (m) => this._onMessage(m);
  }
  /**
   * _Private_ function called by Connection.disconnect
   * Disconnects and sends a last stanza if one is given
   * @param {Element|Builder} [pres] - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
      if (pres) {
        this._conn.send(pres);
      }
      const close = $build("close", { "xmlns": NS.FRAMING });
      this._conn.xmlOutput(close.tree());
      const closeString = builder_default.serialize(close);
      this._conn.rawOutput(closeString);
      try {
        this.socket.send(closeString);
      } catch (e) {
        log_default.warn("Couldn't send <close /> tag.");
      }
    }
    setTimeout(() => this._conn._doDisconnect(), 0);
  }
  /**
   * _Private_ function to disconnect.
   * Just closes the Socket for WebSockets
   */
  _doDisconnect() {
    log_default.debug("WebSockets _doDisconnect was called");
    this._closeSocket();
  }
  /**
   * PrivateFunction _streamWrap
   * _Private_ helper function to wrap a stanza in a <stream> tag.
   * This is used so Strophe can process stanzas from WebSockets like BOSH
   * @param {string} stanza
   */
  // eslint-disable-next-line class-methods-use-this
  _streamWrap(stanza) {
    return "<wrapper>" + stanza + "</wrapper>";
  }
  /**
   * _Private_ function to close the WebSocket.
   *
   * Closes the socket if it is still open and deletes it
   */
  _closeSocket() {
    if (this.socket) {
      try {
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;
        this.socket.close();
      } catch (e) {
        log_default.debug(e.message);
      }
    }
    this.socket = null;
  }
  /**
   * _Private_ function to check if the message queue is empty.
   * @return {true} - True, because WebSocket messages are send immediately after queueing.
   */
  // eslint-disable-next-line class-methods-use-this
  _emptyQueue() {
    return true;
  }
  /**
   * _Private_ function to handle websockets closing.
   * @param {CloseEvent} [e]
   */
  _onClose(e) {
    if (this._conn.connected && !this._conn.disconnecting) {
      log_default.error("Websocket closed unexpectedly");
      this._conn._doDisconnect();
    } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
      log_default.error("Websocket closed unexcectedly");
      this._conn._changeConnectStatus(
        Status.CONNFAIL,
        "The WebSocket connection could not be established or was disconnected."
      );
      this._conn._doDisconnect();
    } else {
      log_default.debug("Websocket closed");
    }
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * Called on stream start/restart when no stream:features
   * has been received.
   * @param {connectionCallback} callback
   */
  _no_auth_received(callback) {
    log_default.error("Server did not offer a supported authentication mechanism");
    this._conn._changeConnectStatus(Status.CONNFAIL, ErrorCondition.NO_AUTH_MECH);
    callback == null ? void 0 : callback.call(this._conn);
    this._conn._doDisconnect();
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * This does nothing for WebSockets
   */
  _onDisconnectTimeout() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ helper function that makes sure all pending requests are aborted.
   */
  _abortAllRequests() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * _Private_ function to handle websockets errors.
   * @param {Object} error - The websocket error.
   */
  _onError(error) {
    log_default.error("Websocket error " + JSON.stringify(error));
    this._conn._changeConnectStatus(
      Status.CONNFAIL,
      "The WebSocket connection could not be established or was disconnected."
    );
    this._disconnect();
  }
  /**
   * _Private_ function called by Connection._onIdle
   * sends all queued stanzas
   */
  _onIdle() {
    const data = this._conn._data;
    if (data.length > 0 && !this._conn.paused) {
      for (let i = 0; i < data.length; i++) {
        if (data[i] !== null) {
          const stanza = data[i] === "restart" ? this._buildStream().tree() : data[i];
          if (stanza === "restart") throw new Error("Wrong type for stanza");
          const rawStanza = builder_default.serialize(stanza);
          this._conn.xmlOutput(stanza);
          this._conn.rawOutput(rawStanza);
          this.socket.send(rawStanza);
        }
      }
      this._conn._data = [];
    }
  }
  /**
   * _Private_ function to handle websockets messages.
   *
   * This function parses each of the messages as if they are full documents.
   * [TODO : We may actually want to use a SAX Push parser].
   *
   * Since all XMPP traffic starts with
   * <stream:stream version='1.0'
   *                xml:lang='en'
   *                xmlns='jabber:client'
   *                xmlns:stream='http://etherx.jabber.org/streams'
   *                id='3697395463'
   *                from='SERVER'>
   *
   * The first stanza will always fail to be parsed.
   *
   * Additionally, the seconds stanza will always be <stream:features> with
   * the stream NS defined in the previous stanza, so we need to 'force'
   * the inclusion of the NS in this stanza.
   *
   * @param {MessageEvent} message - The websocket message event
   */
  _onMessage(message) {
    let elem;
    const close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
    if (message.data === close) {
      this._conn.rawInput(close);
      this._conn.xmlInput(message);
      if (!this._conn.disconnecting) {
        this._conn._doDisconnect();
      }
      return;
    } else if (message.data.search("<open ") === 0) {
      elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
      if (!this._handleStreamStart(elem)) {
        return;
      }
    } else {
      const data = this._streamWrap(message.data);
      elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
    }
    if (this._checkStreamError(elem, Status.ERROR)) {
      return;
    }
    if (this._conn.disconnecting && elem.firstElementChild.nodeName === "presence" && elem.firstElementChild.getAttribute("type") === "unavailable") {
      this._conn.xmlInput(elem);
      this._conn.rawInput(builder_default.serialize(elem));
      return;
    }
    this._conn._dataRecv(elem, message.data);
  }
  /**
   * _Private_ function to handle websockets connection setup.
   * The opening stream tag is sent here.
   * @private
   */
  _onOpen() {
    log_default.debug("Websocket open");
    const start = this._buildStream();
    this._conn.xmlOutput(start.tree());
    const startString = builder_default.serialize(start);
    this._conn.rawOutput(startString);
    this.socket.send(startString);
  }
  /**
   * _Private_ part of the Connection.send function for WebSocket
   * Just flushes the messages that are in the queue
   */
  _send() {
    this._conn.flush();
  }
  /**
   * Send an xmpp:restart stanza.
   */
  _sendRestart() {
    clearTimeout(this._conn._idleTimeout);
    this._conn._onIdle.bind(this._conn)();
  }
};
var websocket_default = Websocket;

// node_modules/strophe.js/src/worker-websocket.js
var WorkerWebsocket = class extends websocket_default {
  /**
   * @typedef {import("./connection.js").default} Connection
   */
  /**
   * Create and initialize a WorkerWebsocket object.
   * @param {Connection} connection - The Connection
   */
  constructor(connection) {
    super(connection);
    this._conn = connection;
    this.worker = new SharedWorker(this._conn.options.worker, "Strophe XMPP Connection");
    this.worker.onerror = (e) => {
      console == null ? void 0 : console.error(e);
      log_default.error(`Shared Worker Error: ${e}`);
    };
  }
  /**
   * @private
   */
  _setSocket() {
    this.socket = {
      /** @param {string} str */
      send: (str) => this.worker.port.postMessage(["send", str]),
      close: () => this.worker.port.postMessage(["_closeSocket"]),
      onopen: () => {
      },
      /** @param {ErrorEvent} e */
      onerror: (e) => this._onError(e),
      /** @param {CloseEvent} e */
      onclose: (e) => this._onClose(e),
      onmessage: () => {
      },
      readyState: null
    };
  }
  _connect() {
    this._setSocket();
    this._messageHandler = (m) => this._onInitialMessage(m);
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_connect", this._conn.service, this._conn.jid]);
  }
  /**
   * @param {Function} callback
   */
  _attach(callback) {
    this._setSocket();
    this._messageHandler = (m) => this._onMessage(m);
    this._conn.connect_callback = callback;
    this.worker.port.start();
    this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
    this.worker.port.postMessage(["_attach", this._conn.service]);
  }
  /**
   * @param {number} status
   * @param {string} jid
   */
  _attachCallback(status, jid) {
    if (status === Status.ATTACHED) {
      this._conn.jid = jid;
      this._conn.authenticated = true;
      this._conn.connected = true;
      this._conn.restored = true;
      this._conn._changeConnectStatus(Status.ATTACHED);
    } else if (status === Status.ATTACHFAIL) {
      this._conn.authenticated = false;
      this._conn.connected = false;
      this._conn.restored = false;
      this._conn._changeConnectStatus(Status.ATTACHFAIL);
    }
  }
  /**
   * @param {Element|Builder} pres - This stanza will be sent before disconnecting.
   */
  _disconnect(pres) {
    pres && this._conn.send(pres);
    const close = $build("close", { "xmlns": NS.FRAMING });
    this._conn.xmlOutput(close.tree());
    const closeString = builder_default.serialize(close);
    this._conn.rawOutput(closeString);
    this.worker.port.postMessage(["send", closeString]);
    this._conn._doDisconnect();
  }
  _closeSocket() {
    this.socket.close();
  }
  /**
   * Called by _onInitialMessage in order to replace itself with the general message handler.
   * This method is overridden by WorkerWebsocket, which manages a
   * websocket connection via a service worker and doesn't have direct access
   * to the socket.
   */
  _replaceMessageHandler() {
    this._messageHandler = (m) => this._onMessage(m);
  }
  /**
   * function that handles messages received from the service worker
   * @private
   * @param {MessageEvent} ev
   */
  _onWorkerMessage(ev) {
    const { data } = ev;
    const method_name = data[0];
    if (method_name === "_onMessage") {
      this._messageHandler(data[1]);
    } else if (method_name in this) {
      try {
        this[
          /** @type {'_attachCallback'|'_onOpen'|'_onClose'|'_onError'} */
          method_name
        ].apply(this, ev.data.slice(1));
      } catch (e) {
        log_default.error(e);
      }
    } else if (method_name === "log") {
      const lmap = {
        debug: LOG_LEVELS.DEBUG,
        info: LOG_LEVELS.INFO,
        warn: LOG_LEVELS.WARN,
        error: LOG_LEVELS.ERROR,
        fatal: LOG_LEVELS.FATAL
      };
      const level = data[1];
      const msg = data[2];
      log_default.log(lmap[level], msg);
    } else {
      log_default.error(`Found unhandled service worker message: ${data}`);
    }
  }
};
var worker_websocket_default = WorkerWebsocket;

// node_modules/strophe.js/src/connection.js
var connectionPlugins = {};
var Connection = class _Connection {
  /**
   * @typedef {Object.<string, string>} Cookie
   * @typedef {Cookie|Object.<string, Cookie>} Cookies
   */
  /**
   * @typedef {Object} ConnectionOptions
   * @property {Cookies} [cookies]
   *  Allows you to pass in cookies that will be included in HTTP requests.
   *  Relevant to both the BOSH and Websocket transports.
   *
   *  The passed in value must be a map of cookie names and string values.
   *
   *  > { "myCookie": {
   *  >     "value": "1234",
   *  >     "domain": ".example.org",
   *  >     "path": "/",
   *  >     "expires": expirationDate
   *  >     }
   *  > }
   *
   *  Note that cookies can't be set in this way for domains other than the one
   *  that's hosting Strophe (i.e. cross-domain).
   *  Those cookies need to be set under those domains, for example they can be
   *  set server-side by making a XHR call to that domain to ask it to set any
   *  necessary cookies.
   * @property {SASLMechanism[]} [mechanisms]
   *  Allows you to specify the SASL authentication mechanisms that this
   *  instance of Connection (and therefore your XMPP client) will support.
   *
   *  The value must be an array of objects with {@link SASLMechanism}
   *  prototypes.
   *
   *  If nothing is specified, then the following mechanisms (and their
   *  priorities) are registered:
   *
   *      Mechanism       Priority
   *      ------------------------
   *      SCRAM-SHA-512   72
   *      SCRAM-SHA-384   71
   *      SCRAM-SHA-256   70
   *      SCRAM-SHA-1     60
   *      PLAIN           50
   *      OAUTHBEARER     40
   *      X-OAUTH2        30
   *      ANONYMOUS       20
   *      EXTERNAL        10
   *
   * @property {boolean} [explicitResourceBinding]
   *  If `explicitResourceBinding` is set to `true`, then the XMPP client
   *  needs to explicitly call {@link Connection.bind} once the XMPP
   *  server has advertised the `urn:ietf:propertys:xml:ns:xmpp-bind` feature.
   *
   *  Making this step explicit allows client authors to first finish other
   *  stream related tasks, such as setting up an XEP-0198 Stream Management
   *  session, before binding the JID resource for this session.
   *
   * @property {'ws'|'wss'} [protocol]
   *  _Note: This option is only relevant to Websocket connections, and not BOSH_
   *
   *  If you want to connect to the current host with a WebSocket connection you
   *  can tell Strophe to use WebSockets through the "protocol" option.
   *  Valid values are `ws` for WebSocket and `wss` for Secure WebSocket.
   *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
   *
   *      const conn = new Strophe.Connection(
   *          "/xmpp-websocket/",
   *          {protocol: "wss"}
   *      );
   *
   *  Note that relative URLs _NOT_ starting with a "/" will also include the path
   *  of the current site.
   *
   *  Also because downgrading security is not permitted by browsers, when using
   *  relative URLs both BOSH and WebSocket connections will use their secure
   *  variants if the current connection to the site is also secure (https).
   *
   * @property {string} [worker]
   *  _Note: This option is only relevant to Websocket connections, and not BOSH_
   *
   *  Set this option to URL from where the shared worker script should be loaded.
   *
   *  To run the websocket connection inside a shared worker.
   *  This allows you to share a single websocket-based connection between
   *  multiple Connection instances, for example one per browser tab.
   *
   *  The script to use is the one in `src/shared-connection-worker.js`.
   *
   * @property {boolean} [sync]
   *  Used to control whether BOSH HTTP requests will be made synchronously or not.
   *  The default behaviour is asynchronous. If you want to make requests
   *  synchronous, make "sync" evaluate to true.
   *
   *  > const conn = new Strophe.Connection("/http-bind/", {sync: true});
   *
   *  You can also toggle this on an already established connection.
   *
   *  > conn.options.sync = true;
   *
   * @property {string[]} [customHeaders]
   *  Used to provide custom HTTP headers to be included in the BOSH HTTP requests.
   *
   * @property {boolean} [keepalive]
   *  Used to instruct Strophe to maintain the current BOSH session across
   *  interruptions such as webpage reloads.
   *
   *  It will do this by caching the sessions tokens in sessionStorage, and when
   *  "restore" is called it will check whether there are cached tokens with
   *  which it can resume an existing session.
   *
   * @property {boolean} [withCredentials]
   *  Used to indicate wether cookies should be included in HTTP requests (by default
   *  they're not).
   *  Set this value to `true` if you are connecting to a BOSH service
   *  and for some reason need to send cookies to it.
   *  In order for this to work cross-domain, the server must also enable
   *  credentials by setting the `Access-Control-Allow-Credentials` response header
   *  to "true". For most usecases however this setting should be false (which
   *  is the default).
   *  Additionally, when using `Access-Control-Allow-Credentials`, the
   *  `Access-Control-Allow-Origin` header can't be set to the wildcard "*", but
   *  instead must be restricted to actual domains.
   *
   * @property {string} [contentType]
   *  Used to change the default Content-Type, which is "text/xml; charset=utf-8".
   *  Can be useful to reduce the amount of CORS preflight requests that are sent
   *  to the server.
   */
  /**
   * Create and initialize a {@link Connection} object.
   *
   * The transport-protocol for this connection will be chosen automatically
   * based on the given service parameter. URLs starting with "ws://" or
   * "wss://" will use WebSockets, URLs starting with "http://", "https://"
   * or without a protocol will use [BOSH](https://xmpp.org/extensions/xep-0124.html).
   *
   * To make Strophe connect to the current host you can leave out the protocol
   * and host part and just pass the path:
   *
   *  const conn = new Strophe.Connection("/http-bind/");
   *
   * @param {string} service - The BOSH or WebSocket service URL.
   * @param {ConnectionOptions} options - A object containing configuration options
   */
  constructor(service, options = {}) {
    this.service = service;
    this.options = options;
    this.setProtocol();
    this.jid = "";
    this.domain = null;
    this.features = null;
    this._sasl_data = {};
    this.do_bind = false;
    this.do_session = false;
    this.mechanisms = {};
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.protocolErrorHandlers = {
      /** @type {Object.<number, Function>} */
      "HTTP": {},
      /** @type {Object.<number, Function>} */
      "websocket": {}
    };
    this._idleTimeout = null;
    this._disconnectTimeout = null;
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.do_authentication = true;
    this.paused = false;
    this.restored = false;
    this._data = [];
    this._uniqueId = 0;
    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;
    this.maxRetries = 5;
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    addCookies(this.options.cookies);
    this.registerSASLMechanisms(this.options.mechanisms);
    this.iqFallbackHandler = new handler_default(
      /**
       * @param {Element} iq
       */
      (iq) => this.send(
        $iq({ type: "error", id: iq.getAttribute("id") }).c("error", { "type": "cancel" }).c("service-unavailable", { "xmlns": NS.STANZAS })
      ),
      null,
      "iq",
      ["get", "set"]
    );
    for (const k in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k)) {
        const F = function() {
        };
        F.prototype = connectionPlugins[k];
        this[k] = new F();
        this[k].init(this);
      }
    }
  }
  /**
   * Extends the Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  static addConnectionPlugin(name, ptype) {
    connectionPlugins[name] = ptype;
  }
  /**
   * Select protocal based on this.options or this.service
   */
  setProtocol() {
    const proto = this.options.protocol || "";
    if (this.options.worker) {
      this._proto = new worker_websocket_default(this);
    } else if (this.service.indexOf("ws:") === 0 || this.service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
      this._proto = new websocket_default(this);
    } else {
      this._proto = new bosh_default(this);
    }
  }
  /**
   * Reset the connection.
   *
   * This function should be called after a connection is disconnected
   * before that connection is reused.
   */
  reset() {
    this._proto._reset();
    this.do_session = false;
    this.do_bind = false;
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.restored = false;
    this._data = [];
    this._requests = [];
    this._uniqueId = 0;
  }
  /**
   * Pause the request manager.
   *
   * This will prevent Strophe from sending any more requests to the
   * server.  This is very useful for temporarily pausing
   * BOSH-Connections while a lot of send() calls are happening quickly.
   * This causes Strophe to send the data in a single request, saving
   * many request trips.
   */
  pause() {
    this.paused = true;
  }
  /**
   * Resume the request manager.
   *
   * This resumes after pause() has been called.
   */
  resume() {
    this.paused = false;
  }
  /**
   * Generate a unique ID for use in <iq/> elements.
   *
   * All <iq/> stanzas are required to have unique id attributes.  This
   * function makes creating these easy.  Each connection instance has
   * a counter which starts from zero, and the value of this counter
   * plus a colon followed by the suffix becomes the unique id. If no
   * suffix is supplied, the counter is used as the unique id.
   *
   * Suffixes are used to make debugging easier when reading the stream
   * data, and their use is recommended.  The counter resets to 0 for
   * every new connection for the same reason.  For connections to the
   * same server that authenticate the same way, all the ids should be
   * the same, which makes it easy to see changes.  This is useful for
   * automated testing as well.
   *
   * @param {string} suffix - A optional suffix to append to the id.
   * @returns {string} A unique string to be used for the id attribute.
   */
  // eslint-disable-next-line class-methods-use-this
  getUniqueId(suffix) {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    if (typeof suffix === "string" || typeof suffix === "number") {
      return uuid + ":" + suffix;
    } else {
      return uuid + "";
    }
  }
  /**
   * Register a handler function for when a protocol (websocker or HTTP)
   * error occurs.
   *
   * NOTE: Currently only HTTP errors for BOSH requests are handled.
   * Patches that handle websocket errors would be very welcome.
   *
   * @example
   *  function onError(err_code){
   *    //do stuff
   *  }
   *
   *  const conn = Strophe.connect('http://example.com/http-bind');
   *  conn.addProtocolErrorHandler('HTTP', 500, onError);
   *  // Triggers HTTP 500 error and onError handler will be called
   *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
   *
   * @param {'HTTP'|'websocket'} protocol - 'HTTP' or 'websocket'
   * @param {number} status_code - Error status code (e.g 500, 400 or 404)
   * @param {Function} callback - Function that will fire on Http error
   */
  addProtocolErrorHandler(protocol, status_code, callback) {
    this.protocolErrorHandlers[protocol][status_code] = callback;
  }
  /**
   * @typedef {Object} Password
   * @property {string} Password.name
   * @property {string} Password.ck
   * @property {string} Password.sk
   * @property {number} Password.iter
   * @property {string} Password.salt
   */
  /**
   * Starts the connection process.
   *
   * As the connection process proceeds, the user supplied callback will
   * be triggered multiple times with status updates.  The callback
   * should take two arguments - the status code and the error condition.
   *
   * The status code will be one of the values in the Strophe.Status
   * constants.  The error condition will be one of the conditions
   * defined in RFC 3920 or the condition 'strophe-parsererror'.
   *
   * The Parameters _wait_, _hold_ and _route_ are optional and only relevant
   * for BOSH connections. Please see XEP 124 for a more detailed explanation
   * of the optional parameters.
   *
   * @param {string} jid - The user's JID.  This may be a bare JID,
   *     or a full JID.  If a node is not supplied, SASL OAUTHBEARER or
   *     SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will
   *     process the provided password value as an access token).
   *   (String or Object) pass - The user's password, or an object containing
   *     the users SCRAM client and server keys, in a fashion described as follows:
   *
   *     { name: String, representing the hash used (eg. SHA-1),
   *       salt: String, base64 encoded salt used to derive the client key,
   *       iter: Int,    the iteration count used to derive the client key,
   *       ck:   String, the base64 encoding of the SCRAM client key
   *       sk:   String, the base64 encoding of the SCRAM server key
   *     }
   * @param {string|Password} pass - The user password
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {string} [route] - The optional route value.
   * @param {string} [authcid] - The optional alternative authentication identity
   *     (username) if intending to impersonate another user.
   *     When using the SASL-EXTERNAL authentication mechanism, for example
   *     with client certificates, then the authcid value is used to
   *     determine whether an authorization JID (authzid) should be sent to
   *     the server. The authzid should NOT be sent to the server if the
   *     authzid and authcid are the same. So to prevent it from being sent
   *     (for example when the JID is already contained in the client
   *     certificate), set authcid to that same JID. See XEP-178 for more
   *     details.
   *  @param {number} [disconnection_timeout=3000] - The optional disconnection timeout
   *     in milliseconds before _doDisconnect will be called.
   */
  connect(jid, pass, callback, wait, hold, route, authcid, disconnection_timeout = 3e3) {
    this.jid = jid;
    this.authzid = getBareJidFromJid(this.jid);
    this.authcid = authcid || getNodeFromJid(this.jid);
    this.pass = pass;
    this.scram_keys = null;
    this.connect_callback = callback;
    this.disconnecting = false;
    this.connected = false;
    this.authenticated = false;
    this.restored = false;
    this.disconnection_timeout = disconnection_timeout;
    this.domain = getDomainFromJid(this.jid);
    this._changeConnectStatus(Status.CONNECTING, null);
    this._proto._connect(wait, hold, route);
  }
  /**
   * Attach to an already created and authenticated BOSH session.
   *
   * This function is provided to allow Strophe to attach to BOSH
   * sessions which have been created externally, perhaps by a Web
   * application.  This is often used to support auto-login type features
   * without putting user credentials into the page.
   *
   * @param {string|Function} jid - The full JID that is bound by the session.
   * @param {string} [sid] - The SID of the BOSH session.
   * @param {number} [rid] - The current RID of the BOSH session.  This RID
   *     will be used by the next request.
   * @param {Function} [callback] - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   *     Other settings will require tweaks to the Strophe.TIMEOUT value.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  attach(jid, sid, rid, callback, wait, hold, wind) {
    if (this._proto instanceof bosh_default && typeof jid === "string") {
      return this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
    } else if (this._proto instanceof worker_websocket_default && typeof jid === "function") {
      const callback2 = jid;
      return this._proto._attach(callback2);
    } else {
      throw new SessionError('The "attach" method is not available for your connection protocol');
    }
  }
  /**
   * Attempt to restore a cached BOSH session.
   *
   * This function is only useful in conjunction with providing the
   * "keepalive":true option when instantiating a new {@link Connection}.
   *
   * When "keepalive" is set to true, Strophe will cache the BOSH tokens
   * RID (Request ID) and SID (Session ID) and then when this function is
   * called, it will attempt to restore the session from those cached
   * tokens.
   *
   * This function must therefore be called instead of connect or attach.
   *
   * For an example on how to use it, please see examples/restore.js
   *
   * @param {string} jid - The user's JID.  This may be a bare JID or a full JID.
   * @param {Function} callback - The connect callback function.
   * @param {number} [wait] - The optional HTTPBIND wait value.  This is the
   *     time the server will wait before returning an empty result for
   *     a request.  The default setting of 60 seconds is recommended.
   * @param {number} [hold] - The optional HTTPBIND hold value.  This is the
   *     number of connections the server will hold at one time.  This
   *     should almost always be set to 1 (the default).
   * @param {number} [wind] - The optional HTTBIND window value.  This is the
   *     allowed range of request ids that are valid.  The default is 5.
   */
  restore(jid, callback, wait, hold, wind) {
    if (!(this._proto instanceof bosh_default) || !this._sessionCachingSupported()) {
      throw new SessionError('The "restore" method can only be used with a BOSH connection.');
    }
    if (this._sessionCachingSupported()) {
      this._proto._restore(jid, callback, wait, hold, wind);
    }
  }
  /**
   * Checks whether sessionStorage and JSON are supported and whether we're
   * using BOSH.
   */
  _sessionCachingSupported() {
    if (this._proto instanceof bosh_default) {
      if (!JSON) {
        return false;
      }
      try {
        sessionStorage.setItem("_strophe_", "_strophe_");
        sessionStorage.removeItem("_strophe_");
      } catch (e) {
        return false;
      }
      return true;
    }
    return false;
  }
  /**
   * User overrideable function that receives XML data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlInput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Node|MessageEvent} elem - The XML data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlInput(elem) {
    return;
  }
  /**
   * User overrideable function that receives XML data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.xmlOutput = function (elem) {
   * >   (user code)
   * > };
   *
   * Due to limitations of current Browsers' XML-Parsers the opening and closing
   * <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
   *
   * BOSH-Connections will have all stanzas wrapped in a <body> tag. See
   * <Bosh.strip> if you want to strip this tag.
   *
   * @param {Element} elem - The XMLdata sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  xmlOutput(elem) {
    return;
  }
  /**
   * User overrideable function that receives raw data coming into the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawInput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data received by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawInput(data) {
    return;
  }
  /**
   * User overrideable function that receives raw data sent to the
   * connection.
   *
   * The default function does nothing.  User code can override this with
   * > Connection.rawOutput = function (data) {
   * >   (user code)
   * > };
   *
   * @param {string} data - The data sent by the connection.
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  rawOutput(data) {
    return;
  }
  /**
   * User overrideable function that receives the new valid rid.
   *
   * The default function does nothing. User code can override this with
   * > Connection.nextValidRid = function (rid) {
   * >    (user code)
   * > };
   *
   * @param {number} rid - The next valid rid
   */
  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  nextValidRid(rid) {
    return;
  }
  /**
   * Send a stanza.
   *
   * This function is called to push data onto the send queue to
   * go out over the wire.  Whenever a request is sent to the BOSH
   * server, all pending data is sent and the queue is flushed.
   *
   * @param {Element|Builder|Element[]|Builder[]} stanza - The stanza to send
   */
  send(stanza) {
    if (stanza === null) return;
    if (Array.isArray(stanza)) {
      stanza.forEach((s) => this._queueData(s instanceof builder_default ? s.tree() : s));
    } else {
      const el = stanza instanceof builder_default ? stanza.tree() : stanza;
      this._queueData(el);
    }
    this._proto._send();
  }
  /**
   * Immediately send any pending outgoing data.
   *
   * Normally send() queues outgoing data until the next idle period
   * (100ms), which optimizes network use in the common cases when
   * several send()s are called in succession. flush() can be used to
   * immediately send all pending data.
   */
  flush() {
    clearTimeout(this._idleTimeout);
    this._onIdle();
  }
  /**
   * Helper function to send presence stanzas. The main benefit is for
   * sending presence stanzas for which you expect a responding presence
   * stanza with the same id (for example when leaving a chat room).
   *
   * @param {Element} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *    out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *    timeout to occur.
   * @return {string} The id used to send the presence.
   */
  sendPresence(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof builder_default ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendPresence");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          if (stanza2.getAttribute("type") === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else if (callback) {
            callback(stanza2);
          }
        },
        null,
        "presence",
        null,
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Helper function to send IQ stanzas.
   *
   * @param {Element|Builder} stanza - The stanza to send.
   * @param {Function} [callback] - The callback function for a successful request.
   * @param {Function} [errback] - The callback function for a failed or timed
   *     out request.  On timeout, the stanza will be null.
   * @param {number} [timeout] - The time specified in milliseconds for a
   *     timeout to occur.
   * @return {string} The id used to send the IQ.
   */
  sendIQ(stanza, callback, errback, timeout) {
    let timeoutHandler = null;
    const el = stanza instanceof builder_default ? stanza.tree() : stanza;
    let id = el.getAttribute("id");
    if (!id) {
      id = this.getUniqueId("sendIQ");
      el.setAttribute("id", id);
    }
    if (typeof callback === "function" || typeof errback === "function") {
      const handler = this.addHandler(
        /** @param {Element} stanza */
        (stanza2) => {
          if (timeoutHandler) this.deleteTimedHandler(timeoutHandler);
          const iqtype = stanza2.getAttribute("type");
          if (iqtype === "result") {
            callback == null ? void 0 : callback(stanza2);
          } else if (iqtype === "error") {
            errback == null ? void 0 : errback(stanza2);
          } else {
            const error = new Error(`Got bad IQ type of ${iqtype}`);
            error.name = "StropheError";
            throw error;
          }
        },
        null,
        "iq",
        ["error", "result"],
        id
      );
      if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, () => {
          this.deleteHandler(handler);
          errback == null ? void 0 : errback(null);
          return false;
        });
      }
    }
    this.send(el);
    return id;
  }
  /**
   * Queue outgoing data for later sending.  Also ensures that the data
   * is a DOMElement.
   * @private
   * @param {Element} element
   */
  _queueData(element) {
    if (element === null || !element.tagName || !element.childNodes) {
      const error = new Error("Cannot queue non-DOMElement.");
      error.name = "StropheError";
      throw error;
    }
    this._data.push(element);
  }
  /**
   * Send an xmpp:restart stanza.
   * @private
   */
  _sendRestart() {
    this._data.push("restart");
    this._proto._sendRestart();
    this._idleTimeout = setTimeout(() => this._onIdle(), 100);
  }
  /**
   * Add a timed handler to the connection.
   *
   * This function adds a timed handler.  The provided handler will
   * be called every period milliseconds until it returns false,
   * the connection is terminated, or the handler is removed.  Handlers
   * that wish to continue being invoked should return true.
   *
   * Because of method binding it is necessary to save the result of
   * this function if you wish to remove a handler with
   * deleteTimedHandler().
   *
   * Note that user handlers are not active until authentication is
   * successful.
   *
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   * @return {TimedHandler} A reference to the handler that can be used to remove it.
   */
  addTimedHandler(period, handler) {
    const thand = new timed_handler_default(period, handler);
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * Delete a timed handler for a connection.
   *
   * This function removes a timed handler from the connection.  The
   * handRef parameter is *not* the function passed to addTimedHandler(),
   * but is the reference returned from addTimedHandler().
   * @param {TimedHandler} handRef - The handler reference.
   */
  deleteTimedHandler(handRef) {
    this.removeTimeds.push(handRef);
  }
  /**
   * @typedef {Object} HandlerOptions
   * @property {boolean} [HandlerOptions.matchBareFromJid]
   * @property {boolean} [HandlerOptions.ignoreNamespaceFragment]
   */
  /**
   * Add a stanza handler for the connection.
   *
   * This function adds a stanza handler to the connection.  The
   * handler callback will be called for any stanza that matches
   * the parameters.  Note that if multiple parameters are supplied,
   * they must all match for the handler to be invoked.
   *
   * The handler will receive the stanza that triggered it as its argument.
   * *The handler should return true if it is to be invoked again;
   * returning false will remove the handler after it returns.*
   *
   * As a convenience, the ns parameters applies to the top level element
   * and also any of its immediate children.  This is primarily to make
   * matching /iq/query elements easy.
   *
   * ### Options
   *
   * With the options argument, you can specify boolean flags that affect how
   * matches are being done.
   *
   * Currently two flags exist:
   *
   * * *matchBareFromJid*:
   *     When set to true, the from parameter and the
   *     from attribute on the stanza will be matched as bare JIDs instead
   *     of full JIDs. To use this, pass {matchBareFromJid: true} as the
   *     value of options. The default value for matchBareFromJid is false.
   *
   * * *ignoreNamespaceFragment*:
   *     When set to true, a fragment specified on the stanza's namespace
   *     URL will be ignored when it's matched with the one configured for
   *     the handler.
   *
   *     This means that if you register like this:
   *
   *     >   connection.addHandler(
   *     >       handler,
   *     >       'http://jabber.org/protocol/muc',
   *     >       null, null, null, null,
   *     >       {'ignoreNamespaceFragment': true}
   *     >   );
   *
   *     Then a stanza with XML namespace of
   *     'http://jabber.org/protocol/muc#user' will also be matched. If
   *     'ignoreNamespaceFragment' is false, then only stanzas with
   *     'http://jabber.org/protocol/muc' will be matched.
   *
   * ### Deleting the handler
   *
   * The return value should be saved if you wish to remove the handler
   * with `deleteHandler()`.
   *
   * @param {Function} handler - The user callback.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string|string[]} type - The stanza type (or types if an array) to match.
   * @param {string} [id] - The stanza id attribute to match.
   * @param {string} [from] - The stanza from attribute to match.
   * @param {HandlerOptions} [options] - The handler options
   * @return {Handler} A reference to the handler that can be used to remove it.
   */
  addHandler(handler, ns, name, type, id, from, options) {
    const hand = new handler_default(handler, ns, name, type, id, from, options);
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * Delete a stanza handler for a connection.
   *
   * This function removes a stanza handler from the connection.  The
   * handRef parameter is *not* the function passed to addHandler(),
   * but is the reference returned from addHandler().
   *
   * @param {Handler} handRef - The handler reference.
   */
  deleteHandler(handRef) {
    this.removeHandlers.push(handRef);
    const i = this.addHandlers.indexOf(handRef);
    if (i >= 0) {
      this.addHandlers.splice(i, 1);
    }
  }
  /**
   * Register the SASL mechanisms which will be supported by this instance of
   * Connection (i.e. which this XMPP client will support).
   * @param {SASLMechanism[]} mechanisms - Array of objects with SASLMechanism prototypes
   */
  registerSASLMechanisms(mechanisms) {
    this.mechanisms = {};
    (mechanisms || [
      sasl_anon_default,
      sasl_external_default,
      sasl_oauthbearer_default,
      sasl_xoauth2_default,
      sasl_plain_default,
      sasl_sha1_default,
      sasl_sha256_default,
      sasl_sha384_default,
      sasl_sha512_default
    ]).forEach((m) => this.registerSASLMechanism(m));
  }
  /**
   * Register a single SASL mechanism, to be supported by this client.
   * @param {any} Mechanism - Object with a Strophe.SASLMechanism prototype
   */
  registerSASLMechanism(Mechanism) {
    const mechanism = new Mechanism();
    this.mechanisms[mechanism.mechname] = mechanism;
  }
  /**
   * Start the graceful disconnection process.
   *
   * This function starts the disconnection process.  This process starts
   * by sending unavailable presence and sending BOSH body of type
   * terminate.  A timeout handler makes sure that disconnection happens
   * even if the BOSH server does not respond.
   * If the Connection object isn't connected, at least tries to abort all pending requests
   * so the connection object won't generate successful requests (which were already opened).
   *
   * The user supplied connection callback will be notified of the
   * progress as this process happens.
   *
   * @param {string} [reason] - The reason the disconnect is occuring.
   */
  disconnect(reason) {
    this._changeConnectStatus(Status.DISCONNECTING, reason);
    if (reason) {
      log_default.info("Disconnect was called because: " + reason);
    } else {
      log_default.debug("Disconnect was called");
    }
    if (this.connected) {
      let pres = null;
      this.disconnecting = true;
      if (this.authenticated) {
        pres = $pres({
          "xmlns": NS.CLIENT,
          "type": "unavailable"
        });
      }
      this._disconnectTimeout = this._addSysTimedHandler(
        this.disconnection_timeout,
        this._onDisconnectTimeout.bind(this)
      );
      this._proto._disconnect(pres);
    } else {
      log_default.debug("Disconnect was called before Strophe connected to the server");
      this._proto._abortAllRequests();
      this._doDisconnect();
    }
  }
  /**
   * _Private_ helper function that makes sure plugins and the user's
   * callback are notified of connection status changes.
   * @param {number} status - the new connection status, one of the values
   *     in Strophe.Status
   * @param {string|null} [condition] - the error condition
   * @param {Element} [elem] - The triggering stanza.
   */
  _changeConnectStatus(status, condition, elem) {
    for (const k in connectionPlugins) {
      if (Object.prototype.hasOwnProperty.call(connectionPlugins, k)) {
        const plugin = this[k];
        if (plugin.statusChanged) {
          try {
            plugin.statusChanged(status, condition);
          } catch (err) {
            log_default.error(`${k} plugin caused an exception changing status: ${err}`);
          }
        }
      }
    }
    if (this.connect_callback) {
      try {
        this.connect_callback(status, condition, elem);
      } catch (e) {
        handleError(e);
        log_default.error(`User connection callback caused an exception: ${e}`);
      }
    }
  }
  /**
   * _Private_ function to disconnect.
   *
   * This is the last piece of the disconnection logic.  This resets the
   * connection and alerts the user's connection callback.
   * @param {string|null} [condition] - the error condition
   */
  _doDisconnect(condition) {
    if (typeof this._idleTimeout === "number") {
      clearTimeout(this._idleTimeout);
    }
    if (this._disconnectTimeout !== null) {
      this.deleteTimedHandler(this._disconnectTimeout);
      this._disconnectTimeout = null;
    }
    log_default.debug("_doDisconnect was called");
    this._proto._doDisconnect();
    this.authenticated = false;
    this.disconnecting = false;
    this.restored = false;
    this.handlers = [];
    this.timedHandlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this._changeConnectStatus(Status.DISCONNECTED, condition);
    this.connected = false;
  }
  /**
   * _Private_ handler to processes incoming data from the the connection.
   *
   * Except for _connect_cb handling the initial connection request,
   * this function handles the incoming data for all requests.  This
   * function also fires stanza handlers that match each incoming
   * stanza.
   * @param {Element | Request} req - The request that has data ready.
   * @param {string} [raw] - The stanza as raw string.
   */
  _dataRecv(req, raw) {
    const elem = (
      /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req
    );
    if (elem === null) {
      return;
    }
    if (this.xmlInput !== _Connection.prototype.xmlInput) {
      if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
        this.xmlInput(elem.childNodes[0]);
      } else {
        this.xmlInput(elem);
      }
    }
    if (this.rawInput !== _Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(builder_default.serialize(elem));
      }
    }
    while (this.removeHandlers.length > 0) {
      const hand = this.removeHandlers.pop();
      const i = this.handlers.indexOf(hand);
      if (i >= 0) {
        this.handlers.splice(i, 1);
      }
    }
    while (this.addHandlers.length > 0) {
      this.handlers.push(this.addHandlers.pop());
    }
    if (this.disconnecting && this._proto._emptyQueue()) {
      this._doDisconnect();
      return;
    }
    const type = elem.getAttribute("type");
    if (type !== null && type === "terminate") {
      if (this.disconnecting) {
        return;
      }
      let cond = elem.getAttribute("condition");
      const conflict = elem.getElementsByTagName("conflict");
      if (cond !== null) {
        if (cond === "remote-stream-error" && conflict.length > 0) {
          cond = "conflict";
        }
        this._changeConnectStatus(Status.CONNFAIL, cond);
      } else {
        this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.UNKNOWN_REASON);
      }
      this._doDisconnect(cond);
      return;
    }
    forEachChild(
      elem,
      null,
      /** @param {Element} child */
      (child) => {
        const matches = [];
        this.handlers = this.handlers.reduce((handlers, handler) => {
          try {
            if (handler.isMatch(child) && (this.authenticated || !handler.user)) {
              if (handler.run(child)) {
                handlers.push(handler);
              }
              matches.push(handler);
            } else {
              handlers.push(handler);
            }
          } catch (e) {
            log_default.warn("Removing Strophe handlers due to uncaught exception: " + e.message);
          }
          return handlers;
        }, []);
        if (!matches.length && this.iqFallbackHandler.isMatch(child)) {
          this.iqFallbackHandler.run(child);
        }
      }
    );
  }
  /**
   * @callback connectionCallback
   * @param {Connection} connection
   */
  /**
   * _Private_ handler for initial connection request.
   *
   * This handler is used to process the initial connection request
   * response from the BOSH server. It is used to set up authentication
   * handlers and start the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {Element | Request} req - The current request.
   * @param {connectionCallback} _callback - low level (xmpp) connect callback function.
   *     Useful for plugins with their own xmpp connect callback (when they
   *     want to do something special).
   * @param {string} [raw] - The stanza as raw string.
   */
  _connect_cb(req, _callback, raw) {
    log_default.debug("_connect_cb was called");
    this.connected = true;
    let bodyWrap;
    try {
      bodyWrap = /** @type {Element} */
      "_reqToData" in this._proto ? this._proto._reqToData(
        /** @type {Request} */
        req
      ) : req;
    } catch (e) {
      if (e.name !== ErrorCondition.BAD_FORMAT) {
        throw e;
      }
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.BAD_FORMAT);
      this._doDisconnect(ErrorCondition.BAD_FORMAT);
    }
    if (!bodyWrap) {
      return;
    }
    if (this.xmlInput !== _Connection.prototype.xmlInput) {
      if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
        this.xmlInput(bodyWrap.childNodes[0]);
      } else {
        this.xmlInput(bodyWrap);
      }
    }
    if (this.rawInput !== _Connection.prototype.rawInput) {
      if (raw) {
        this.rawInput(raw);
      } else {
        this.rawInput(builder_default.serialize(bodyWrap));
      }
    }
    const conncheck = this._proto._connect_cb(bodyWrap);
    if (conncheck === Status.CONNFAIL) {
      return;
    }
    let hasFeatures;
    if (bodyWrap.getElementsByTagNameNS) {
      hasFeatures = bodyWrap.getElementsByTagNameNS(NS.STREAM, "features").length > 0;
    } else {
      hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
    }
    if (!hasFeatures) {
      this._proto._no_auth_received(_callback);
      return;
    }
    const matched = Array.from(bodyWrap.getElementsByTagName("mechanism")).map((m) => this.mechanisms[m.textContent]).filter((m) => m);
    if (matched.length === 0) {
      if (bodyWrap.getElementsByTagName("auth").length === 0) {
        this._proto._no_auth_received(_callback);
        return;
      }
    }
    if (this.do_authentication !== false) {
      this.authenticate(matched);
    }
  }
  /**
   * Sorts an array of objects with prototype SASLMechanism according to
   * their priorities.
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   */
  // eslint-disable-next-line  class-methods-use-this
  sortMechanismsByPriority(mechanisms) {
    for (let i = 0; i < mechanisms.length - 1; ++i) {
      let higher = i;
      for (let j = i + 1; j < mechanisms.length; ++j) {
        if (mechanisms[j].priority > mechanisms[higher].priority) {
          higher = j;
        }
      }
      if (higher !== i) {
        const swap = mechanisms[i];
        mechanisms[i] = mechanisms[higher];
        mechanisms[higher] = swap;
      }
    }
    return mechanisms;
  }
  /**
   * Set up authentication
   *
   * Continues the initial connection request by setting up authentication
   * handlers and starting the authentication process.
   *
   * SASL authentication will be attempted if available, otherwise
   * the code will fall back to legacy authentication.
   *
   * @param {SASLMechanism[]} matched - Array of SASL mechanisms supported.
   */
  authenticate(matched) {
    if (!this._attemptSASLAuth(matched)) {
      this._attemptLegacyAuth();
    }
  }
  /**
   * Iterate through an array of SASL mechanisms and attempt authentication
   * with the highest priority (enabled) mechanism.
   *
   * @private
   * @param {SASLMechanism[]} mechanisms - Array of SASL mechanisms.
   * @return {Boolean} mechanism_found - true or false, depending on whether a
   *  valid SASL mechanism was found with which authentication could be started.
   */
  _attemptSASLAuth(mechanisms) {
    mechanisms = this.sortMechanismsByPriority(mechanisms || []);
    let mechanism_found = false;
    for (let i = 0; i < mechanisms.length; ++i) {
      if (!mechanisms[i].test(this)) {
        continue;
      }
      this._sasl_success_handler = this._addSysHandler(
        this._sasl_success_cb.bind(this),
        null,
        "success",
        null,
        null
      );
      this._sasl_failure_handler = this._addSysHandler(
        this._sasl_failure_cb.bind(this),
        null,
        "failure",
        null,
        null
      );
      this._sasl_challenge_handler = this._addSysHandler(
        this._sasl_challenge_cb.bind(this),
        null,
        "challenge",
        null,
        null
      );
      this._sasl_mechanism = mechanisms[i];
      this._sasl_mechanism.onStart(this);
      const request_auth_exchange = $build("auth", {
        "xmlns": NS.SASL,
        "mechanism": this._sasl_mechanism.mechname
      });
      if (this._sasl_mechanism.isClientFirst) {
        const response = this._sasl_mechanism.clientChallenge(this);
        request_auth_exchange.t((0, import_abab.btoa)(
          /** @type {string} */
          response
        ));
      }
      this.send(request_auth_exchange.tree());
      mechanism_found = true;
      break;
    }
    return mechanism_found;
  }
  /**
   * _Private_ handler for the SASL challenge
   * @private
   * @param {Element} elem
   */
  async _sasl_challenge_cb(elem) {
    const challenge = (0, import_abab.atob)(getText(elem));
    const response = await this._sasl_mechanism.onChallenge(this, challenge);
    const stanza = $build("response", { "xmlns": NS.SASL });
    if (response) stanza.t((0, import_abab.btoa)(response));
    this.send(stanza.tree());
    return true;
  }
  /**
   * Attempt legacy (i.e. non-SASL) authentication.
   * @private
   */
  _attemptLegacyAuth() {
    if (getNodeFromJid(this.jid) === null) {
      this._changeConnectStatus(Status.CONNFAIL, ErrorCondition.MISSING_JID_NODE);
      this.disconnect(ErrorCondition.MISSING_JID_NODE);
    } else {
      this._changeConnectStatus(Status.AUTHENTICATING, null);
      this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1");
      this.send(
        $iq({
          "type": "get",
          "to": this.domain,
          "id": "_auth_1"
        }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).tree()
      );
    }
  }
  /**
   * _Private_ handler for legacy authentication.
   *
   * This handler is called in response to the initial <iq type='get'/>
   * for legacy authentication.  It builds an authentication <iq/> and
   * sends it, creating a handler (calling back to _auth2_cb()) to
   * handle the result
   * @private
   * @return {false} `false` to remove the handler.
   */
  // eslint-disable-next-line no-unused-vars
  //
  _onLegacyAuthIQResult() {
    const pass = typeof this.pass === "string" ? this.pass : "";
    const iq = $iq({ type: "set", id: "_auth_2" }).c("query", { xmlns: NS.AUTH }).c("username", {}).t(getNodeFromJid(this.jid)).up().c("password").t(pass);
    if (!getResourceFromJid(this.jid)) {
      this.jid = getBareJidFromJid(this.jid) + "/strophe";
    }
    iq.up().c("resource", {}).t(getResourceFromJid(this.jid));
    this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
    this.send(iq.tree());
    return false;
  }
  /**
   * _Private_ handler for succesful SASL authentication.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_success_cb(elem) {
    if (this._sasl_data["server-signature"]) {
      let serverSignature;
      const success = (0, import_abab.atob)(getText(elem));
      const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
      const matches = success.match(attribMatch);
      if (matches[1] === "v") {
        serverSignature = matches[2];
      }
      if (serverSignature !== this._sasl_data["server-signature"]) {
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
          this.deleteHandler(this._sasl_challenge_handler);
          this._sasl_challenge_handler = null;
        }
        this._sasl_data = {};
        return this._sasl_failure_cb(null);
      }
    }
    log_default.info("SASL authentication succeeded.");
    if (this._sasl_data.keys) {
      this.scram_keys = this._sasl_data.keys;
    }
    if (this._sasl_mechanism) {
      this._sasl_mechanism.onSuccess();
    }
    this.deleteHandler(this._sasl_failure_handler);
    this._sasl_failure_handler = null;
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    const streamfeature_handlers = [];
    const wrapper = (handlers, elem2) => {
      while (handlers.length) {
        this.deleteHandler(handlers.pop());
      }
      this._onStreamFeaturesAfterSASL(elem2);
      return false;
    };
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper(streamfeature_handlers, elem2),
        null,
        "stream:features",
        null,
        null
      )
    );
    streamfeature_handlers.push(
      this._addSysHandler(
        /** @param {Element} elem */
        (elem2) => wrapper(streamfeature_handlers, elem2),
        NS.STREAM,
        "features",
        null,
        null
      )
    );
    this._sendRestart();
    return false;
  }
  /**
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onStreamFeaturesAfterSASL(elem) {
    this.features = elem;
    for (let i = 0; i < elem.childNodes.length; i++) {
      const child = elem.childNodes[i];
      if (child.nodeName === "bind") {
        this.do_bind = true;
      }
      if (child.nodeName === "session") {
        this.do_session = true;
      }
    }
    if (!this.do_bind) {
      this._changeConnectStatus(Status.AUTHFAIL, null);
      return false;
    } else if (!this.options.explicitResourceBinding) {
      this.bind();
    } else {
      this._changeConnectStatus(Status.BINDREQUIRED, null);
    }
    return false;
  }
  /**
   * Sends an IQ to the XMPP server to bind a JID resource for this session.
   *
   * https://tools.ietf.org/html/rfc6120#section-7.5
   *
   * If `explicitResourceBinding` was set to a truthy value in the options
   * passed to the Connection constructor, then this function needs
   * to be called explicitly by the client author.
   *
   * Otherwise it'll be called automatically as soon as the XMPP server
   * advertises the "urn:ietf:params:xml:ns:xmpp-bind" stream feature.
   */
  bind() {
    if (!this.do_bind) {
      log_default.info(`Connection.prototype.bind called but "do_bind" is false`);
      return;
    }
    this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
    const resource = getResourceFromJid(this.jid);
    if (resource) {
      this.send(
        $iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).c("resource", {}).t(resource).tree()
      );
    } else {
      this.send($iq({ type: "set", id: "_bind_auth_2" }).c("bind", { xmlns: NS.BIND }).tree());
    }
  }
  /**
   * _Private_ handler for binding result and session start.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onResourceBindResultIQ(elem) {
    if (elem.getAttribute("type") === "error") {
      log_default.warn("Resource binding failed.");
      const conflict = elem.getElementsByTagName("conflict");
      let condition;
      if (conflict.length > 0) {
        condition = ErrorCondition.CONFLICT;
      }
      this._changeConnectStatus(Status.AUTHFAIL, condition, elem);
      return false;
    }
    const bind = elem.getElementsByTagName("bind");
    if (bind.length > 0) {
      const jidNode = bind[0].getElementsByTagName("jid");
      if (jidNode.length > 0) {
        this.authenticated = true;
        this.jid = getText(jidNode[0]);
        if (this.do_session) {
          this._establishSession();
        } else {
          this._changeConnectStatus(Status.CONNECTED, null);
        }
      }
    } else {
      log_default.warn("Resource binding failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
  }
  /**
   * Send IQ request to establish a session with the XMPP server.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   */
  _establishSession() {
    if (!this.do_session) {
      throw new Error(
        `Connection.prototype._establishSession called but apparently ${NS.SESSION} wasn't advertised by the server`
      );
    }
    this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2");
    this.send($iq({ type: "set", id: "_session_auth_2" }).c("session", { xmlns: NS.SESSION }).tree());
  }
  /**
   * _Private_ handler for the server's IQ response to a client's session
   * request.
   *
   * This sets Connection.authenticated to true on success, which
   * starts the processing of user handlers.
   *
   * See https://xmpp.org/rfcs/rfc3921.html#session
   *
   * Note: The protocol for session establishment has been determined as
   * unnecessary and removed in RFC-6121.
   * @private
   * @param {Element} elem - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _onSessionResultIQ(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this.authenticated = false;
      log_default.warn("Session creation failed.");
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      return false;
    }
    return false;
  }
  /**
   * _Private_ handler for SASL authentication failure.
   * @param {Element} [elem] - The matching stanza.
   * @return {false} `false` to remove the handler.
   */
  _sasl_failure_cb(elem) {
    if (this._sasl_success_handler) {
      this.deleteHandler(this._sasl_success_handler);
      this._sasl_success_handler = null;
    }
    if (this._sasl_challenge_handler) {
      this.deleteHandler(this._sasl_challenge_handler);
      this._sasl_challenge_handler = null;
    }
    if (this._sasl_mechanism) this._sasl_mechanism.onFailure();
    this._changeConnectStatus(Status.AUTHFAIL, null, elem);
    return false;
  }
  /**
   * _Private_ handler to finish legacy authentication.
   *
   * This handler is called when the result from the jabber:iq:auth
   * <iq/> stanza is returned.
   * @private
   * @param {Element} elem - The stanza that triggered the callback.
   * @return {false} `false` to remove the handler.
   */
  _auth2_cb(elem) {
    if (elem.getAttribute("type") === "result") {
      this.authenticated = true;
      this._changeConnectStatus(Status.CONNECTED, null);
    } else if (elem.getAttribute("type") === "error") {
      this._changeConnectStatus(Status.AUTHFAIL, null, elem);
      this.disconnect("authentication failed");
    }
    return false;
  }
  /**
   * _Private_ function to add a system level timed handler.
   *
   * This function is used to add a TimedHandler for the
   * library code.  System timed handlers are allowed to run before
   * authentication is complete.
   * @param {number} period - The period of the handler.
   * @param {Function} handler - The callback function.
   */
  _addSysTimedHandler(period, handler) {
    const thand = new timed_handler_default(period, handler);
    thand.user = false;
    this.addTimeds.push(thand);
    return thand;
  }
  /**
   * _Private_ function to add a system level stanza handler.
   *
   * This function is used to add a Handler for the
   * library code.  System stanza handlers are allowed to run before
   * authentication is complete.
   * @param {Function} handler - The callback function.
   * @param {string} ns - The namespace to match.
   * @param {string} name - The stanza name to match.
   * @param {string} type - The stanza type attribute to match.
   * @param {string} id - The stanza id attribute to match.
   */
  _addSysHandler(handler, ns, name, type, id) {
    const hand = new handler_default(handler, ns, name, type, id);
    hand.user = false;
    this.addHandlers.push(hand);
    return hand;
  }
  /**
   * _Private_ timeout handler for handling non-graceful disconnection.
   *
   * If the graceful disconnect process does not complete within the
   * time allotted, this handler finishes the disconnect anyway.
   * @return {false} `false` to remove the handler.
   */
  _onDisconnectTimeout() {
    log_default.debug("_onDisconnectTimeout was called");
    this._changeConnectStatus(Status.CONNTIMEOUT, null);
    this._proto._onDisconnectTimeout();
    this._doDisconnect();
    return false;
  }
  /**
   * _Private_ handler to process events during idle cycle.
   *
   * This handler is called every 100ms to fire timed handlers that
   * are ready and keep poll requests going.
   */
  _onIdle() {
    while (this.addTimeds.length > 0) {
      this.timedHandlers.push(this.addTimeds.pop());
    }
    while (this.removeTimeds.length > 0) {
      const thand = this.removeTimeds.pop();
      const i = this.timedHandlers.indexOf(thand);
      if (i >= 0) {
        this.timedHandlers.splice(i, 1);
      }
    }
    const now = (/* @__PURE__ */ new Date()).getTime();
    const newList = [];
    for (let i = 0; i < this.timedHandlers.length; i++) {
      const thand = this.timedHandlers[i];
      if (this.authenticated || !thand.user) {
        const since = thand.lastCalled + thand.period;
        if (since - now <= 0) {
          if (thand.run()) {
            newList.push(thand);
          }
        } else {
          newList.push(thand);
        }
      }
    }
    this.timedHandlers = newList;
    clearTimeout(this._idleTimeout);
    this._proto._onIdle();
    if (this.connected) {
      this._idleTimeout = setTimeout(() => this._onIdle(), 100);
    }
  }
};
var connection_default = Connection;

// node_modules/strophe.js/src/stanza.js
var PARSE_ERROR_NS = "http://www.w3.org/1999/xhtml";
function toStanza(string, throwErrorIfInvalidNS) {
  const doc = xmlHtmlNode(string);
  if (doc.getElementsByTagNameNS(PARSE_ERROR_NS, "parsererror").length) {
    throw new Error(`Parser Error: ${string}`);
  }
  const node = doc.firstElementChild;
  if (["message", "iq", "presence"].includes(node.nodeName.toLowerCase()) && node.namespaceURI !== "jabber:client" && node.namespaceURI !== "jabber:server") {
    const err_msg = `Invalid namespaceURI ${node.namespaceURI}`;
    if (throwErrorIfInvalidNS) {
      throw new Error(err_msg);
    } else {
      log_default.error(err_msg);
    }
  }
  return node;
}
var Stanza = class {
  /**
   * @param { string[] } strings
   * @param { any[] } values
   */
  constructor(strings, values) {
    this.strings = strings;
    this.values = values;
  }
  /**
   * @return { string }
   */
  toString() {
    this.string = this.string || this.strings.reduce((acc, str) => {
      const idx = this.strings.indexOf(str);
      const value = this.values.length > idx ? this.values[idx].toString() : "";
      return acc + str + value;
    }, "");
    return this.string;
  }
  /**
   * @return { Element }
   */
  tree() {
    this.node = this.node ?? toStanza(this.toString(), true);
    return this.node;
  }
};
function stx(strings, ...values) {
  return new Stanza(strings, values);
}

// node_modules/strophe.js/src/index.js
var Strophe = {
  /** @constant: VERSION */
  VERSION: "3.0.0",
  /**
   * @returns {number}
   */
  get TIMEOUT() {
    return bosh_default.getTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set TIMEOUT(n) {
    bosh_default.setTimeoutMultiplier(n);
  },
  /**
   * @returns {number}
   */
  get SECONDARY_TIMEOUT() {
    return bosh_default.getSecondaryTimeoutMultplier();
  },
  /**
   * @param {number} n
   */
  set SECONDARY_TIMEOUT(n) {
    bosh_default.setSecondaryTimeoutMultiplier(n);
  },
  ...utils_exports,
  ...log_default,
  shims: shims_exports,
  Request: request_default,
  // Transports
  Bosh: bosh_default,
  Websocket: websocket_default,
  WorkerWebsocket: worker_websocket_default,
  Connection: connection_default,
  Handler: handler_default,
  // Available authentication mechanisms
  SASLAnonymous: sasl_anon_default,
  SASLPlain: sasl_plain_default,
  SASLSHA1: sasl_sha1_default,
  SASLSHA256: sasl_sha256_default,
  SASLSHA384: sasl_sha384_default,
  SASLSHA512: sasl_sha512_default,
  SASLOAuthBearer: sasl_oauthbearer_default,
  SASLExternal: sasl_external_default,
  SASLXOAuth2: sasl_xoauth2_default,
  Builder: builder_default,
  ElementType,
  ErrorCondition,
  LogLevel: LOG_LEVELS,
  /** @type {Object.<string, string>} */
  NS,
  SASLMechanism: sasl_default,
  /** @type {Status} */
  Status,
  TimedHandler: timed_handler_default,
  XHTML: {
    ...XHTML,
    validTag,
    validCSS,
    validAttribute
  },
  /**
   * Render a DOM element and all descendants to a String.
   * @method Strophe.serialize
   * @param {Element|Builder} elem - A DOM element.
   * @return {string} - The serialized element tree as a String.
   */
  serialize(elem) {
    return builder_default.serialize(elem);
  },
  /**
   * @typedef {import('./constants').LogLevel} LogLevel
   *
   * Library consumers can use this function to set the log level of Strophe.
   * The default log level is Strophe.LogLevel.INFO.
   * @param {LogLevel} level
   * @example Strophe.setLogLevel(Strophe.LogLevel.DEBUG);
   */
  setLogLevel(level) {
    log_default.setLogLevel(level);
  },
  /**
   * This function is used to extend the current namespaces in
   * Strophe.NS. It takes a key and a value with the key being the
   * name of the new namespace, with its actual value.
   * @example: Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
   *
   * @param {string} name - The name under which the namespace will be
   *     referenced under Strophe.NS
   * @param {string} value - The actual namespace.
   */
  addNamespace(name, value) {
    Strophe.NS[name] = value;
  },
  /**
   * Extends the Strophe.Connection object with the given plugin.
   * @param {string} name - The name of the extension.
   * @param {Object} ptype - The plugin's prototype.
   */
  addConnectionPlugin(name, ptype) {
    connection_default.addConnectionPlugin(name, ptype);
  }
};
globalThis.$build = $build;
globalThis.$iq = $iq;
globalThis.$msg = $msg;
globalThis.$pres = $pres;
globalThis.Strophe = Strophe;
export {
  $build,
  $iq,
  $msg,
  $pres,
  builder_default as Builder,
  request_default as Request,
  Stanza,
  Strophe,
  stx,
  toStanza
};
/*! Bundled license information:

strophe.js/src/worker-websocket.js:
  (**
   * @license MIT
   * @copyright JC Brand
   *)
*/
//# sourceMappingURL=strophe__js.js.map
